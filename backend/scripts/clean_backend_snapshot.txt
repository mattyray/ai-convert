# CLEAN BACKEND CODE SNAPSHOT
# Essential files for HuggingFace debugging
# Total files: 40
# Excludes: migrations, tests, media, large JSON files

# ===== CONFIGURATION FILES =====


## requirements.txt
```
# Core
Django==5.1.6
gunicorn==23.0.0
whitenoise==6.9.0
psycopg2-binary==2.9.10

# Environment + security
django-environ==0.12.0
cryptography==44.0.3

# Auth + social login
django-allauth==65.6.0
django-crispy-forms==2.3
crispy-bootstrap5==2024.10
django-extensions==4.1

# Media + storage
cloudinary==1.44.0
django-cloudinary-storage==0.3.0
Pillow==10.0.0

# APIs + HTTP
stripe==12.0.1
openai==1.78.1
httpx==0.28.1
requests==2.32.3
urllib3==2.4.0
certifi==2025.4.26
idna==3.10
charset-normalizer==3.4.2

djangorestframework==3.16.0

# Type + utility
pydantic>=2.6,<2.10
typing_extensions==4.13.0
typing-inspection==0.4.0
pytz==2025.2
tzdata==2025.2

# Optional: Data tools (remove if not used in chat utils)
numpy==2.2.4
pandas==2.2.3
pandas-stubs==2.2.3.250308
python-dateutil==2.9.0.post0
tablib==3.8.0
openpyxl==3.1.5

PyJWT==2.10.1

face-recognition==1.3.0
dlib==20.0.0
cmake==4.0.2

django-cors-headers==4.6.0
gradio-client==1.10.3

```

## requirements-dev.txt
```
-r requirements.txt

flake8==7.2.0
flake8-bandit==4.1.1
mypy==1.15.0
mypy_extensions==1.1.0
pytest==8.3.5
pytest-django==4.11.1
safety==3.5.0
safety-schemas==0.0.14

```

## docker-compose.yml
```
services:
  # PostgreSQL Database
  db:
    image: postgres:15-alpine
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      POSTGRES_DB: faceswap_db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres_password
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Django Backend
  backend:
    build: 
      context: .
      dockerfile: Dockerfile
    ports:
      - "8002:8000"
    environment:
      - DEBUG=True
      - DJANGO_DEBUG=True
      - DJANGO_SETTINGS_MODULE=django_project.settings.dev
      - DATABASE_URL=postgresql://postgres:postgres_password@db:5432/faceswap_db
      - DJANGO_SECRET_KEY=dev-secret-key-change-in-production
      - DJANGO_ALLOWED_HOSTS=localhost,127.0.0.1,backend,0.0.0.0
      - CLOUDINARY_URL=${CLOUDINARY_URL}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - STRIPE_SECRET_KEY=${STRIPE_SECRET_KEY}
      - STRIPE_PUBLISHABLE_KEY=${STRIPE_PUBLISHABLE_KEY}
      # 🔑 FIXED: Correct private space URL + HF token for authentication
      - HUGGINGFACE_FACESWAP_URL=https://mnraynor90-facefusionfastapi-private.hf.space
      - HUGGINGFACE_API_TOKEN=${HUGGINGFACE_API_TOKEN}
    volumes:
      - .:/app
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    depends_on:
      db:
        condition: service_healthy
    command: ["python", "manage.py", "runserver", "0.0.0.0:8000"]

volumes:
  postgres_data:
  static_volume:
  media_volume:
```

## fly.toml
```
# fly.toml app configuration file generated for ai-face-swap-app on 2025-06-17T18:20:43-04:00
#
# See https://fly.io/docs/reference/configuration/ for information about how to use this file.
#

app = 'ai-face-swap-app'
primary_region = 'ewr'
console_command = '/code/manage.py shell'

[build]

[deploy]
  release_command = 'python manage.py migrate --noinput'

[env]
  PORT = '8000'

[http_service]
  internal_port = 8000
  force_https = true
  auto_stop_machines = 'stop'
  auto_start_machines = true
  min_machines_running = 0
  processes = ['app']

[[vm]]
  memory = '2gb'
  cpu_kind = 'shared'
  cpus = 1

[[statics]]
  guest_path = '/code/static'
  url_prefix = '/static/'

```

## manage.py
```
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "django_project.settings.dev")
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

```


# ===== PYTHON CODE =====


## accounts/models.py
```python
from django.contrib.auth.models import AbstractBaseUser, PermissionsMixin
from django.db import models
from django.utils import timezone
from django.contrib.auth.base_user import BaseUserManager


class CustomUserManager(BaseUserManager):
    def create_user(self, email, password=None, **extra_fields):
        if not email:
            raise ValueError("The Email field must be set")
        email = self.normalize_email(email)
        user = self.model(email=email, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, email, password, **extra_fields):
        extra_fields.setdefault("is_staff", True)
        extra_fields.setdefault("is_superuser", True)
        if not extra_fields.get("is_staff") or not extra_fields.get("is_superuser"):
            raise ValueError("Superuser must have is_staff=True and is_superuser=True.")
        return self.create_user(email, password, **extra_fields)


class CustomUser(AbstractBaseUser, PermissionsMixin):
    email = models.EmailField(unique=True)
    first_name = models.CharField(max_length=30, blank=True)
    last_name = models.CharField(max_length=30, blank=True)
    is_staff = models.BooleanField(default=False)
    is_active = models.BooleanField(default=True)
    date_joined = models.DateTimeField(default=timezone.now)

    USERNAME_FIELD = "email"
    REQUIRED_FIELDS = []

    objects = CustomUserManager()

    def __str__(self):
        return self.email

```

## accounts/serializers.py
```python
from rest_framework import serializers
from django.contrib.auth import get_user_model

User = get_user_model()


class CustomUserSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True, required=True, min_length=8)

    class Meta:
        model = User
        fields = ["id", "email", "first_name", "last_name", "password"]
        read_only_fields = ["id"]

    def create(self, validated_data):
        user = User.objects.create_user(
            email=validated_data["email"],
            password=validated_data["password"],
            first_name=validated_data.get("first_name", ""),
            last_name=validated_data.get("last_name", "")
        )
        return user

    def update(self, instance, validated_data):
        for attr, value in validated_data.items():
            if attr == "password":
                instance.set_password(value)
            else:
                setattr(instance, attr, value)
        instance.save()
        return instance

```

## accounts/__init__.py
```python

```

## accounts/apps.py
```python
from django.apps import AppConfig


class AccountsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'accounts'

```

## accounts/forms.py
```python
from django.contrib.auth import get_user_model
from django.contrib.auth.forms import UserCreationForm, UserChangeForm

class CustomUserCreationForm(UserCreationForm):
    class Meta:
        model = get_user_model()
        fields = ("email",)  # Remove 'username'

class CustomUserChangeForm(UserChangeForm):
    class Meta:
        model = get_user_model()
        fields = ("email",)  # Remove 'username'

```

## accounts/admin.py
```python
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin
from .models import CustomUser
from .forms import CustomUserCreationForm, CustomUserChangeForm

@admin.register(CustomUser)
class CustomUserAdmin(UserAdmin):
    add_form = CustomUserCreationForm
    form = CustomUserChangeForm
    model = CustomUser

    list_display = ("email", "first_name", "last_name", "is_staff", "is_active")
    list_filter = ("is_staff", "is_active")
    ordering = ("email",)

    fieldsets = (
        (None, {"fields": ("email", "password")}),
        ("Personal Info", {"fields": ("first_name", "last_name")}),
        ("Permissions", {"fields": ("is_staff", "is_active", "groups", "user_permissions")}),
        ("Important dates", {"fields": ("last_login", "date_joined")}),
    )

    add_fieldsets = (
        (None, {
            "classes": ("wide",),
            "fields": ("email", "password1", "password2", "is_staff", "is_active"),
        }),
    )

```

## accounts/api_auth.py
```python
from rest_framework.authtoken.views import ObtainAuthToken
from rest_framework.authtoken.models import Token
from rest_framework.response import Response
from rest_framework import status
from django.contrib.auth import authenticate
from rest_framework.views import APIView
from rest_framework.permissions import AllowAny


class CustomAuthToken(APIView):
    permission_classes = [AllowAny]

    def post(self, request, *args, **kwargs):
        email = request.data.get("email")
        password = request.data.get("password")

        if not email or not password:
            return Response({"error": "Email and password are required."}, status=status.HTTP_400_BAD_REQUEST)

        user = authenticate(request, username=email, password=password)

        if not user:
            return Response({"error": "Invalid credentials."}, status=status.HTTP_400_BAD_REQUEST)

        token, _ = Token.objects.get_or_create(user=user)
        return Response({
            "token": token.key,
            "user_id": user.id,
            "email": user.email,
        })

```

## accounts/urls.py
```python
from django.urls import path
from .views import SignupAPIView, UserProfileAPIView, CustomAuthToken

app_name = "accounts"

urlpatterns = [
    path("signup/", SignupAPIView.as_view(), name="signup"),
    path("me/", UserProfileAPIView.as_view(), name="user-profile"),
    path("login/", CustomAuthToken.as_view(), name="token-login"),
]

```

## accounts/views.py
```python
from rest_framework import generics, permissions, status
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.authtoken.views import ObtainAuthToken
from rest_framework.authtoken.models import Token
from django.contrib.auth import authenticate, get_user_model

from .serializers import CustomUserSerializer

User = get_user_model()


class SignupAPIView(generics.CreateAPIView):
    """
    POST /api/accounts/signup/
    """
    queryset = User.objects.all()
    serializer_class = CustomUserSerializer
    permission_classes = [permissions.AllowAny]


class UserProfileAPIView(APIView):
    """
    GET, PUT /api/accounts/me/
    """
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        serializer = CustomUserSerializer(request.user)
        return Response(serializer.data)

    def put(self, request):
        serializer = CustomUserSerializer(request.user, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class CustomAuthToken(ObtainAuthToken):
    """
    POST /api/accounts/login/
    Authenticates using email and password.
    """
    def post(self, request, *args, **kwargs):
        email = request.data.get("email")
        password = request.data.get("password")

        if not email or not password:
            return Response({"error": "Email and password are required."}, status=status.HTTP_400_BAD_REQUEST)

        user = authenticate(request, email=email, password=password)
        if not user:
            return Response({"error": "Invalid credentials."}, status=status.HTTP_401_UNAUTHORIZED)

        token, created = Token.objects.get_or_create(user=user)
        return Response({"token": token.key})

```

## faceswap/models.py
```python
from django.db import models
from django.contrib.auth import get_user_model

User = get_user_model()

class FaceSwapJob(models.Model):
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('processing', 'Processing'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    source_image = models.ImageField(upload_to='faceswap/source/')
    target_image = models.ImageField(upload_to='faceswap/target/')
    result_image = models.ImageField(upload_to='faceswap/results/', null=True, blank=True)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    error_message = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        ordering = ['-created_at']
    
    def __str__(self):
        return f"FaceSwap Job {self.id} - {self.user.email} - {self.status}"
```

## faceswap/serializers.py
```python
from rest_framework import serializers
from .models import FaceSwapJob

class FaceSwapJobSerializer(serializers.ModelSerializer):
    class Meta:
        model = FaceSwapJob
        fields = ['id', 'source_image', 'target_image', 'result_image', 
                 'status', 'error_message', 'created_at', 'completed_at']
        read_only_fields = ['id', 'result_image', 'status', 'error_message', 
                           'created_at', 'completed_at']

class FaceSwapCreateSerializer(serializers.ModelSerializer):
    class Meta:
        model = FaceSwapJob
        fields = ['source_image', 'target_image']
```

## faceswap/__init__.py
```python

```

## faceswap/apps.py
```python
from django.apps import AppConfig

class FaceswapConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'faceswap'
```

## faceswap/admin.py
```python
from django.contrib import admin
from .models import FaceSwapJob

@admin.register(FaceSwapJob)
class FaceSwapJobAdmin(admin.ModelAdmin):
    list_display = ['id', 'user', 'status', 'created_at', 'completed_at']
    list_filter = ['status', 'created_at']
    search_fields = ['user__email']
    readonly_fields = ['created_at', 'completed_at']
    
    def get_readonly_fields(self, request, obj=None):
        if obj:  # Editing existing object
            return self.readonly_fields + ['user', 'source_image', 'target_image']
        return self.readonly_fields
```

## faceswap/huggingface_utils.py
```python
# faceswap/huggingface_utils.py - SOLUTION 1: Client.duplicate() approach

import requests
import time
from django.conf import settings
from django.core.files.base import ContentFile
import tempfile
import os
import base64
from gradio_client import Client
import random
import threading

# 🔗 HuggingFace Space Configuration
HUGGINGFACE_SPACE_URL = getattr(settings, 'HUGGINGFACE_FACESWAP_URL', 
                               'https://mnraynor90-facefusionfastapi-private.hf.space')

# 🔑 HuggingFace Authentication Token (from environment)
HUGGINGFACE_API_TOKEN = getattr(settings, 'HUGGINGFACE_API_TOKEN', None)

class SingletonGradioClient:
    """
    SOLUTION 1: Use Client.duplicate() to create unlimited-usage private space
    This bypasses ALL rate limiting by creating your own copy of the space
    """
    _instance = None
    _client = None
    _duplicated_space_url = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super(SingletonGradioClient, cls).__new__(cls)
        return cls._instance
    
    def get_client(self):
        """Get duplicated space client - ELIMINATES RATE LIMITING COMPLETELY!"""
        if self._client is None:
            with self._lock:
                if self._client is None:
                    try:
                        print("🔌 Creating DUPLICATED space client...")
                        print(f"🏠 Original Space: {HUGGINGFACE_SPACE_URL}")
                        
                        if not HUGGINGFACE_API_TOKEN:
                            raise Exception("HUGGINGFACE_API_TOKEN required for space duplication!")
                        
                        print(f"🔑 Token: {HUGGINGFACE_API_TOKEN[:10]}... ✅")
                        
                        # 🌟 THE ULTIMATE FIX: Duplicate the space for unlimited usage!
                        # This creates a private copy that bypasses all rate limiting
                        print("🚀 Duplicating space for unlimited usage...")
                        
                        # Extract space name from URL
                        # https://mnraynor90-facefusionfastapi-private.hf.space → mnraynor90/facefusionfastapi-private
                        space_name = "mnraynor90/facefusionfastapi-private"
                        
                        print(f"📋 Duplicating space: {space_name}")
                        
                        self._client = Client.duplicate(
                            space_name,
                            hf_token=HUGGINGFACE_API_TOKEN,
                            private=True,  # Keep it private
                            hardware="t4-small"  # Match your T4 hardware
                        )
                        
                        print("✅ DUPLICATED space client created successfully!")
                        print("🚫 Rate limiting is now COMPLETELY ELIMINATED!")
                        print("💰 You own this space copy - unlimited requests!")
                        
                    except Exception as e:
                        print(f"❌ Failed to duplicate space: {e}")
                        print("💡 Falling back to direct connection...")
                        
                        # Fallback to direct connection with auth
                        self._client = Client(
                            HUGGINGFACE_SPACE_URL, 
                            hf_token=HUGGINGFACE_API_TOKEN
                        )
                        print("⚠️ Using direct connection - may still hit rate limits")
                        
        return self._client
    
    def reset_client(self):
        """Reset the client if it becomes invalid"""
        with self._lock:
            print("🔄 Resetting duplicated space client...")
            self._client = None

# Global singleton instance
gradio_singleton = SingletonGradioClient()

class FaceFusionClient:
    """
    Enhanced FaceFusion client using duplicated space (unlimited usage)
    """
    
    def __init__(self):
        self.base_url = HUGGINGFACE_SPACE_URL
        
    def get_image_url(self, image_field):
        """Convert Django ImageField to accessible URL"""
        try:
            if hasattr(image_field, 'url'):
                image_url = image_field.url
                
                if image_url.startswith('http'):
                    return image_url
                
                if image_url.startswith('/') and hasattr(image_field, 'name'):
                    try:
                        import cloudinary.utils
                        cloudinary_url = cloudinary.utils.cloudinary_url(image_field.name)[0]
                        print(f"✅ Using Cloudinary URL: {cloudinary_url}")
                        return cloudinary_url
                    except Exception as e:
                        print(f"⚠️ Cloudinary failed: {e}")
                        base_url = getattr(settings, 'BASE_URL', 'http://127.0.0.1:8002')
                        return f"{base_url}{image_url}"
                
                return image_url
            else:
                raise Exception("Invalid image field")
        except Exception as e:
            raise Exception(f"Failed to get image URL: {str(e)}")
    
    def swap_faces(self, source_image_field, target_image_field, max_retries=2):
        """
        Perform face swap using DUPLICATED SPACE - unlimited usage!
        """
        # Get URLs
        source_url = self.get_image_url(source_image_field)
        target_url = self.get_image_url(target_image_field)
        
        last_error = None
        
        for attempt in range(max_retries):
            try:
                print(f"🔄 DUPLICATED SPACE face swap attempt {attempt + 1}/{max_retries}")
                print(f"  Source: {source_url[:80]}...")
                print(f"  Target: {target_url[:80]}...")
                
                # Use the DUPLICATED space client (unlimited usage!)
                client = gradio_singleton.get_client()
                
                # Call the API on your private duplicated space
                result = client.predict(
                    source_url,
                    target_url,
                    api_name="/process_images"
                )
                
                print(f"📋 Result type: {type(result)}, length: {len(result) if result else 0}")
                
                if not result or len(result) < 2:
                    raise Exception(f"Invalid result format: {result}")
                
                result_image = result[0]
                status_message = result[1]
                
                print(f"📋 Status: {status_message}")
                
                # Handle different result types
                if hasattr(result_image, 'save'):  # PIL Image
                    print("✅ Got PIL Image, converting to bytes")
                    import io
                    img_buffer = io.BytesIO()
                    result_image.save(img_buffer, format='JPEG', quality=90)
                    return img_buffer.getvalue()
                    
                elif isinstance(result_image, str) and os.path.exists(result_image):  # File path
                    print(f"✅ Got file path: {result_image}")
                    with open(result_image, 'rb') as f:
                        return f.read()
                        
                elif isinstance(result_image, dict) and 'path' in result_image:  # Dict with path
                    file_path = result_image['path']
                    if os.path.exists(file_path):
                        with open(file_path, 'rb') as f:
                            return f.read()
                            
                else:
                    raise Exception(f"Unexpected result format: {type(result_image)}")
                    
            except Exception as e:
                last_error = e
                error_msg = str(e).lower()
                
                print(f"❌ Attempt {attempt + 1} failed: {e}")
                
                # With duplicated space, rate limiting should be impossible
                if 'slow down' in error_msg or 'too many' in error_msg or 'rate limit' in error_msg:
                    print("🚨 UNEXPECTED: Still getting rate limited with duplicated space!")
                    print("💡 This suggests duplication failed - check logs above")
                    
                    if attempt < max_retries - 1:
                        gradio_singleton.reset_client()
                        delay = 5 + random.uniform(0, 3)
                        print(f"⏳ Resetting and waiting {delay:.1f}s...")
                        time.sleep(delay)
                        continue
                    else:
                        raise Exception("Rate limited even with duplicated space - check HUGGINGFACE_API_TOKEN!")
                
                # For other errors, shorter delay
                elif attempt < max_retries - 1:
                    delay = 3 + random.uniform(0, 2)
                    print(f"⏳ Retrying in {delay:.1f}s...")
                    time.sleep(delay)
                    continue
                else:
                    break
        
        # All attempts failed
        raise Exception(f"Face swap failed after {max_retries} attempts. Last error: {last_error}")

def process_face_swap(job_id):
    """
    Process a face swap job using DUPLICATED SPACE (unlimited usage)
    """
    from .models import FaceSwapJob
    from django.utils import timezone
    
    try:
        job = FaceSwapJob.objects.get(id=job_id)
        job.status = 'processing'
        job.save()
        
        print(f"🚀 Processing face swap job {job_id} with DUPLICATED SPACE")
        
        # Initialize client
        client = FaceFusionClient()
        
        # Perform face swap
        result_image_data = client.swap_faces(job.source_image, job.target_image)
        
        # Save result
        result_filename = f"faceswap_result_{job.id}_{int(time.time())}.jpg"
        result_file = ContentFile(result_image_data, name=result_filename)
        job.result_image.save(result_filename, result_file)
        
        # Update status
        job.status = 'completed'
        job.completed_at = timezone.now()
        job.save()
        
        print(f"✅ Face swap job {job_id} completed successfully with DUPLICATED SPACE")
        return True
        
    except FaceSwapJob.DoesNotExist:
        print(f"❌ Face swap job {job_id} not found")
        return False
    except Exception as e:
        print(f"❌ Face swap job {job_id} failed: {e}")
        try:
            job.status = 'failed'
            job.error_message = str(e)
            job.save()
        except:
            pass
        return False
```

## faceswap/urls.py
```python
# Update your faceswap/urls.py to include the test endpoint

from django.urls import path
from .views import (
    FaceSwapCreateView,
    FaceSwapListView, 
    FaceSwapDetailView,
    FaceSwapStatusView,
    FaceSwapTestURLView,
    DebugGradioAPIView  # Add this import
)

app_name = "faceswap"

urlpatterns = [
    path("create/", FaceSwapCreateView.as_view(), name="create"),
    path("jobs/", FaceSwapListView.as_view(), name="list"),
    path("jobs/<int:pk>/", FaceSwapDetailView.as_view(), name="detail"),
    path("status/<int:job_id>/", FaceSwapStatusView.as_view(), name="status"),
    path("test-url/", FaceSwapTestURLView.as_view(), name="test-url"),
    path("debug/", DebugGradioAPIView.as_view(), name="debug"),  # Add this line
]
```

## faceswap/views.py
```python
from rest_framework import generics, status
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.views import APIView
from django.shortcuts import get_object_or_404
from .models import FaceSwapJob
from .serializers import FaceSwapJobSerializer, FaceSwapCreateSerializer
from .huggingface_utils import process_face_swap
import threading

class FaceSwapCreateView(generics.CreateAPIView):
    """
    POST /api/faceswap/create/
    Upload source and target images to start face swapping
    """
    serializer_class = FaceSwapCreateSerializer
    permission_classes = [IsAuthenticated]
    
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        # Create job with current user
        job = serializer.save(user=request.user)
        
        # Start processing in background thread (or use Celery if available)
        def process_in_background():
            process_face_swap(job.id)
        
        thread = threading.Thread(target=process_in_background)
        thread.daemon = True
        thread.start()
        
        # Return job details
        response_serializer = FaceSwapJobSerializer(job)
        return Response(response_serializer.data, status=status.HTTP_201_CREATED)

class FaceSwapListView(generics.ListAPIView):
    """
    GET /api/faceswap/jobs/
    List all face swap jobs for the current user
    """
    serializer_class = FaceSwapJobSerializer
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        return FaceSwapJob.objects.filter(user=self.request.user)

class FaceSwapDetailView(generics.RetrieveAPIView):
    """
    GET /api/faceswap/jobs/{id}/
    Get details of a specific face swap job
    """
    serializer_class = FaceSwapJobSerializer
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        return FaceSwapJob.objects.filter(user=self.request.user)

class FaceSwapStatusView(APIView):
    """
    GET /api/faceswap/status/{id}/
    Quick status check for a face swap job
    """
    permission_classes = [IsAuthenticated]
    
    def get(self, request, job_id):
        job = get_object_or_404(FaceSwapJob, id=job_id, user=request.user)
        return Response({
            'id': job.id,
            'status': job.status,
            'error_message': job.error_message,
            'result_image': job.result_image.url if job.result_image else None,
            'created_at': job.created_at,
            'completed_at': job.completed_at
        })
    
# Add this to your existing faceswap/views.py file

class FaceSwapTestURLView(APIView):
    """
    POST /api/faceswap/test-url/
    Test face swapping with direct URLs (for testing with Cloudinary)
    """
    permission_classes = [IsAuthenticated]
    
    def post(self, request):
        source_url = request.data.get('source_url')
        target_url = request.data.get('target_url')
        
        if not source_url or not target_url:
            return Response({
                'error': 'Both source_url and target_url are required'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            from .huggingface_utils import FaceFusionClient
            client = FaceFusionClient()
            
            # Create a simple mock object with url property
            class MockImageField:
                def __init__(self, url):
                    self.url = url
            
            source_mock = MockImageField(source_url)
            target_mock = MockImageField(target_url)
            
            # Test the face swap
            result_data = client.swap_faces(source_mock, target_mock)
            
            # Return base64 encoded result for testing
            import base64
            result_b64 = base64.b64encode(result_data).decode('utf-8')
            
            return Response({
                'status': 'success',
                'message': 'Face swap completed successfully',
                'result_size': len(result_data),
                'result_preview': f"data:image/jpeg;base64,{result_b64[:100]}..."  # First 100 chars
            })
            
        except Exception as e:
            return Response({
                'error': f'Face swap failed: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
# Add this debug view to your faceswap/views.py

class DebugGradioAPIView(APIView):
    """
    Debug endpoint to test Gradio Space connectivity
    """
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        try:
            from .huggingface_utils import HUGGINGFACE_SPACE_URL
            import requests
            
            results = {}
            
            # Test 1: Check if the space is running
            try:
                response = requests.get(HUGGINGFACE_SPACE_URL, timeout=10)
                results['space_status'] = f"HTTP {response.status_code}"
                results['space_accessible'] = response.status_code == 200
            except Exception as e:
                results['space_status'] = f"Error: {str(e)}"
                results['space_accessible'] = False
            
            # Test 2: Try to get API info using gradio_client
            try:
                from gradio_client import Client
                client = Client(HUGGINGFACE_SPACE_URL)
                api_info = client.view_api(all_endpoints=True)
                results['gradio_client_success'] = True
                results['api_info'] = str(api_info)
            except Exception as e:
                results['gradio_client_success'] = False
                results['gradio_client_error'] = str(e)
            
            # Test 3: Try common Gradio endpoints
            endpoints_to_test = [
                '/api/predict',
                '/run/predict', 
                '/predict',
                '/api',
                '/info',
                '/app_info'
            ]
            
            results['endpoint_tests'] = {}
            for endpoint in endpoints_to_test:
                try:
                    url = f"{HUGGINGFACE_SPACE_URL}{endpoint}"
                    response = requests.get(url, timeout=5)
                    results['endpoint_tests'][endpoint] = {
                        'status': response.status_code,
                        'content_type': response.headers.get('content-type', 'unknown'),
                        'content_preview': response.text[:200] if response.text else 'No content'
                    }
                except Exception as e:
                    results['endpoint_tests'][endpoint] = {
                        'error': str(e)
                    }
            
            # Test 4: Check if it's a Gradio 4 or 5 app
            try:
                response = requests.get(f"{HUGGINGFACE_SPACE_URL}/info", timeout=5)
                if response.status_code == 200:
                    results['gradio_info'] = response.json()
            except:
                pass
                
            return Response({
                'space_url': HUGGINGFACE_SPACE_URL,
                'debug_results': results
            })
            
        except Exception as e:
            return Response({
                'error': f'Debug failed: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
```

## imagegen/models.py
```python
from django.db import models
from django.conf import settings
from cloudinary_storage.storage import MediaCloudinaryStorage

class GeneratedImage(models.Model):
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="generated_images"
    )
    prompt = models.TextField()
    match_name = models.CharField(max_length=100)
    selfie = models.ImageField(
        upload_to="uploads/selfies/",
        storage=MediaCloudinaryStorage()  # ✅ Explicitly use Cloudinary
    )
    output_image = models.ImageField(
        upload_to="uploads/fused/", 
        null=True, 
        blank=True,
        storage=MediaCloudinaryStorage()  # ✅ Explicitly use Cloudinary
    )
    output_url = models.URLField(blank=True, default="")
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.match_name} - {self.created_at.strftime('%Y-%m-%d %H:%M')}"
```

## imagegen/serializers.py
```python
from rest_framework import serializers
from .models import GeneratedImage

class GeneratedImageSerializer(serializers.ModelSerializer):
    class Meta:
        model = GeneratedImage
        fields = '__all__'
        read_only_fields = ['id', 'created_at', 'user']

```

## imagegen/face_match.py
```python
import face_recognition
import numpy as np
import json
from pathlib import Path

EMBEDDINGS_PATH = Path(__file__).resolve().parent.parent / "face_data" / "embeddings.json"

def match_face(uploaded_image_path):
    """
    Match an uploaded face image against historical figures
    Returns best match with confidence score
    """
    try:
        print(f"🔍 Processing uploaded image: {uploaded_image_path}")
        
        # Load the uploaded selfie
        image = face_recognition.load_image_file(uploaded_image_path)
        face_locations = face_recognition.face_locations(image)
        
        if not face_locations:
            return {"error": "No face detected in uploaded image."}
        
        if len(face_locations) > 1:
            print(f"⚠️  Multiple faces detected, using the largest one.")
        
        # Get encoding for the uploaded face
        uploaded_encoding = face_recognition.face_encodings(image, known_face_locations=face_locations)[0]
        print(f"✅ Successfully extracted face encoding from uploaded image")
        
    except Exception as e:
        print(f"❌ Error processing uploaded image: {str(e)}")
        return {"error": f"Failed to process uploaded image: {e}"}

    # Load historical figure embeddings
    try:
        if not EMBEDDINGS_PATH.exists():
            return {"error": f"Embeddings file not found at {EMBEDDINGS_PATH}. Run embed_cloudinary_faces.py first."}
            
        with open(EMBEDDINGS_PATH, "r") as f:
            known_embeddings = json.load(f)
            
        if not known_embeddings:
            return {"error": "No historical embeddings found. Run embed_cloudinary_faces.py first."}
            
        print(f"📚 Loaded {len(known_embeddings)} historical figure embeddings")
        
    except Exception as e:
        print(f"❌ Error loading embeddings: {str(e)}")
        return {"error": f"Failed to load historical embeddings: {e}"}

    # Compare using cosine similarity
    def cosine_similarity(a, b):
        """Calculate cosine similarity between two vectors"""
        return np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))

    best_match = None
    best_score = -1
    all_scores = []

    print("🎯 Comparing against historical figures...")
    
    for entry in known_embeddings:
        try:
            name = entry["name"]
            known_vector = np.array(entry["embedding"])
            
            # Calculate similarity score
            score = cosine_similarity(uploaded_encoding, known_vector)
            all_scores.append((name, score))
            
            print(f"  • {name}: {score:.3f}")
            
            if score > best_score:
                best_score = score
                best_match = name
                
        except Exception as e:
            print(f"⚠️  Error processing {entry.get('name', 'unknown')}: {str(e)}")
            continue

    # Sort all scores for debugging
    all_scores.sort(key=lambda x: x[1], reverse=True)
    print(f"\n🏆 Top 3 matches:")
    for i, (name, score) in enumerate(all_scores[:3]):
        print(f"  {i+1}. {name}: {score:.3f}")

    if best_match and best_score > 0.3:  # Minimum confidence threshold
        print(f"\n✅ Best match: {best_match} (confidence: {best_score:.3f})")
        return {
            "match_name": best_match, 
            "score": best_score,
            "all_matches": all_scores[:5]  # Return top 5 for debugging
        }
    else:
        print(f"\n❌ No confident match found (best score: {best_score:.3f})")
        return {
            "error": f"No confident match found. Best match was {best_match} with score {best_score:.3f}",
            "all_matches": all_scores[:5]
        }
```

## imagegen/__init__.py
```python

```

## imagegen/apps.py
```python
from django.apps import AppConfig


class ImagegenConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'imagegen'

```

## imagegen/admin.py
```python
from django.contrib import admin
from .models import GeneratedImage

@admin.register(GeneratedImage)
class GeneratedImageAdmin(admin.ModelAdmin):
    list_display = ('match_name', 'user', 'created_at')
    readonly_fields = ('created_at',)

```

## imagegen/urls.py
```python
from django.urls import path
from .views import GenerateImageView, ImageStatusView, UnlockImageView, ListGeneratedImagesView

urlpatterns = [
    path("generate/", GenerateImageView.as_view(), name="generate-image"),
    path("status/<int:prediction_id>/", ImageStatusView.as_view(), name="image-status"),
    path("unlock/", UnlockImageView.as_view(), name="unlock-generation"),
    path("list/", ListGeneratedImagesView.as_view(), name="list-images"),  # New endpoint
]
```

## imagegen/views.py
```python
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status, permissions
from .models import GeneratedImage
from .face_match import match_face
from faceswap.huggingface_utils import FaceFusionClient  # Use the working client!
import tempfile
import base64
from django.core.files.base import ContentFile
import os
from django.core.files.uploadedfile import InMemoryUploadedFile
import io
import time
import random

# Map historical figures to their Cloudinary URLs
HISTORICAL_FIGURES = {
    "Princess Diana": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921365/princess_diana_ueb9ha.png",
    "Marilyn Monroe": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921365/marilyn_monroe_geys6v.png",
    "Pocahontas": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921365/Pocahontas_kp0obo.png",
    "Napoleon": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921365/napolean_ukozvo.png",
    "Marie Antoinette": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921363/Marie_Antoinette_fvjtgy.png",
    "Keith Haring": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921362/keith_k7b5xw.png",
    "Malcolm X": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921362/malcolm_x_a8sluo.png",
    "Jimi Hendrix": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921362/jimi_hendrix_u07bvu.png",
    "Joan of Arc": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921362/Joan_of_Arc_vvi28l.png",
    "Leonardo da Vinci": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921362/leonardo_davinci_lv7gy8.png",
    "Cleopatra": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921359/cleopatra_zcslcx.png",
    "Frida Kahlo": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921358/frida_khalo_wq6qyl.png",
    "JFK": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921358/jfk_rznzq0.png",
    "James Dean": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921358/james_dean_wvmc5c.png",
    "Coco Chanel": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921358/Coco_Chanel_mnx6s9.png",
    "Elvis Presley": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921841/elvis_heazqa.png",
    "Che Guevara": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921355/Che_Guevara_n8nmln.png",
    "Alexander the Great": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921354/alexander_the_great_mcdwpy.png",
}

class GenerateImageView(APIView):
    permission_classes = [permissions.AllowAny]

    def perform_face_swap_with_retry(self, source_mock, target_mock, match_name, max_retries=4):
        """
        Use the SAME working approach as FaceSwapTestURLView
        """
        print(f"🔄 Starting face swap for {match_name} using working FaceFusionClient")
        
        try:
            # Use the exact same client that works in test-url
            client = FaceFusionClient()
            result_data = client.swap_faces(source_mock, target_mock)
            
            print(f"✅ Face swap completed using FaceFusionClient: {len(result_data)} bytes")
            return result_data
            
        except Exception as e:
            error_msg = str(e).lower()
            print(f"❌ Face swap failed: {e}")
            
            # If it's a rate limiting error, provide helpful message
            if any(keyword in error_msg for keyword in [
                'slow down', 'too many', 'rate limit', 'concurrent requests',
                'quota exceeded', 'throttled', 'busy'
            ]):
                raise Exception("Rate limited. Please try again in a few minutes.")
            else:
                raise e

    def post(self, request):
        selfie = request.FILES.get("selfie")
        if not selfie:
            return Response({"error": "Selfie is required"}, status=status.HTTP_400_BAD_REQUEST)

        # Read the file content once and store it
        selfie_content = selfie.read()
        
        # Save uploaded selfie to temporary file for face matching
        with tempfile.NamedTemporaryFile(delete=False, suffix=".jpg") as tmp:
            tmp.write(selfie_content)
            tmp_path = tmp.name

        # Create a new file object for Django model (reset file pointer)
        selfie_for_model = InMemoryUploadedFile(
            file=io.BytesIO(selfie_content),
            field_name=selfie.field_name,
            name=selfie.name,
            content_type=selfie.content_type,
            size=len(selfie_content),
            charset=selfie.charset,
        )

        temp_image = None
        try:
            # Step 1: Match face with historical figures
            print("🔍 Starting face matching...")
            match_result = match_face(tmp_path)
            if "error" in match_result:
                return Response(match_result, status=status.HTTP_400_BAD_REQUEST)

            match_name = match_result["match_name"]
            match_score = match_result.get("score", 0)
            
            print(f"🎯 Face match found: {match_name} (score: {match_score:.3f})")

            # Check if we have a historical image for this match
            historical_image_url = HISTORICAL_FIGURES.get(match_name)
            if not historical_image_url:
                return Response({
                    "error": f"No historical image available for {match_name}. Available figures: {list(HISTORICAL_FIGURES.keys())}"
                }, status=status.HTTP_400_BAD_REQUEST)

            # Step 2: Create database record with the fresh file object
            temp_image = GeneratedImage.objects.create(
                user=request.user if request.user.is_authenticated else None,
                prompt=f"You as {match_name}",
                match_name=match_name,
                selfie=selfie_for_model,
                output_url="",
            )

            print(f"📝 Created GeneratedImage record: {temp_image.id}")

            # Step 3: Create mock image field objects for face swap (SAME AS TEST-URL)
            class MockImageField:
                def __init__(self, url):
                    self.url = url

            source_mock = MockImageField(temp_image.selfie.url)  # User's selfie
            target_mock = MockImageField(historical_image_url)   # Historical figure

            print(f"🔄 Starting face swap: {temp_image.selfie.url} -> {historical_image_url}")

            # Step 4: Use the SAME approach as working test-url endpoint
            result_image_data = self.perform_face_swap_with_retry(
                source_mock, target_mock, match_name
            )

            print(f"✅ Face swap completed: {len(result_image_data)} bytes")

            # Step 5: Save the result
            temp_image.output_image.save(
                f"{temp_image.id}_fused_{match_name.replace(' ', '_')}.jpg", 
                ContentFile(result_image_data)
            )
            temp_image.save()

            print(f"💾 Saved result to: {temp_image.output_image.url}")

            return Response({
                "id": temp_image.id,
                "match_name": match_name,
                "match_score": round(match_score, 3),
                "message": f"Successfully transformed you into {match_name}!",
                "output_image_url": temp_image.output_image.url,
                "original_selfie_url": temp_image.selfie.url,
                "historical_figure_url": historical_image_url
            })

        except Exception as e:
            print(f"❌ Error in GenerateImageView: {str(e)}")
            # Clean up on error
            if temp_image:
                try:
                    temp_image.delete()
                except:
                    pass
            
            return Response({
                "error": f"Face processing failed: {str(e)}"
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
        finally:
            # Clean up temporary file
            try:
                os.unlink(tmp_path)
            except:
                pass


class ImageStatusView(APIView):
    """Get status of a generated image"""
    def get(self, request, prediction_id):
        try:
            generated_image = GeneratedImage.objects.get(id=prediction_id)
            
            return Response({
                "id": generated_image.id,
                "status": "completed" if generated_image.output_image else "processing",
                "match_name": generated_image.match_name,
                "prompt": generated_image.prompt,
                "output_image_url": generated_image.output_image.url if generated_image.output_image else None,
                "created_at": generated_image.created_at
            })
        except GeneratedImage.DoesNotExist:
            return Response(
                {"error": "Generated image not found"}, 
                status=status.HTTP_404_NOT_FOUND
            )


class UnlockImageView(APIView):
    """Reset generation counter for demo purposes"""
    def post(self, request):
        request.session["image_generation_count"] = 0
        return Response({"message": "Unlock granted. You can generate again."})


class ListGeneratedImagesView(APIView):
    """List all generated images for a user"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        images = GeneratedImage.objects.filter(user=request.user).order_by('-created_at')
        
        results = []
        for img in images:
            results.append({
                "id": img.id,
                "match_name": img.match_name,
                "prompt": img.prompt,
                "output_image_url": img.output_image.url if img.output_image else None,
                "selfie_url": img.selfie.url,
                "created_at": img.created_at
            })
        
        return Response({"images": results})
```

## django_project/asgi.py
```python
"""
ASGI config for django_project project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django_project.settings.prod')

application = get_asgi_application()

```

## django_project/__init__.py
```python

```

## django_project/urls.py
```python
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static
from django.http import JsonResponse

def api_root(request):
    return JsonResponse({"message": "API is running!"})

def health_check(request):
    return JsonResponse({"status": "healthy"})

urlpatterns = [
    path("", api_root),
    path("health/", health_check, name="health-check"),  # Add this line
    path("admin/", admin.site.urls),
    path("api/accounts/", include(("accounts.urls", "accounts"), namespace="accounts")),
    path("api/chat/", include(("chat.urls", "chat"), namespace="chat")),
    path("api/imagegen/", include("imagegen.urls")),
    path("api/faceswap/", include(("faceswap.urls", "faceswap"), namespace="faceswap")),
]

if settings.DEBUG:
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
```

## django_project/wsgi.py
```python
"""
WSGI config for django_project project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django_project.settings.prod')

application = get_wsgi_application()

```

## django_project/settings/__init__.py
```python

```

## django_project/settings/test.py
```python
from .base import *

DEBUG = False
SECRET_KEY = "test-secret-key"

STRIPE_PUBLISHABLE_KEY = "pk_test_dummy"
STRIPE_SECRET_KEY = "sk_test_dummy"
STRIPE_WEBHOOK_SECRET = "whsec_dummy"
stripe.api_key = STRIPE_SECRET_KEY



EMAIL_BACKEND = "django.core.mail.backends.locmem.EmailBackend"
EMAIL_HOST = "localhost"
EMAIL_PORT = 1025
EMAIL_USE_TLS = False
EMAIL_HOST_USER = ""
EMAIL_HOST_PASSWORD = ""
DEFAULT_FROM_EMAIL = "test@example.com"


# In-memory test DB
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "test.sqlite3",
    }
}

RECAPTCHA_PUBLIC_KEY = "test"
RECAPTCHA_PRIVATE_KEY = "test"

# 👇 Google SSO override here only for tests
SOCIALACCOUNT_PROVIDERS = {
    'google': {
        'SCOPE': ['profile', 'email'],
        'AUTH_PARAMS': {'access_type': 'online'},
        'OAUTH_PKCE_ENABLED': True,
        'APP': {
            'client_id': 'test-client-id',
            'secret': 'test-secret',
            'key': ''
        }
    }
}

SECURE_SSL_REDIRECT = False
SECURE_HSTS_SECONDS = 0
SECURE_HSTS_INCLUDE_SUBDOMAINS = False
SECURE_HSTS_PRELOAD = False
SESSION_COOKIE_SECURE = False
CSRF_COOKIE_SECURE = False

```

## django_project/settings/dev.py
```python
# backend/django_project/settings/dev.py
from .base import *

DEBUG = True

# Database for local development
DATABASES = {
    "default": env.db_url("DATABASE_URL", default="postgresql://postgres:postgres_password@db:5432/faceswap_db")
}

# Add localhost to allowed hosts
ALLOWED_HOSTS = env.list("DJANGO_ALLOWED_HOSTS", default=[
    "localhost", "127.0.0.1", "0.0.0.0", "backend"
])

# CORS settings for local development
CORS_ALLOWED_ORIGINS = [
    "http://localhost:5173",  # Vite dev server
    "http://127.0.0.1:5173",
]
```

## django_project/settings/prod.py
```python
from .base import *
import dj_database_url
import os

DEBUG = False

# Security settings for production
SECURE_SSL_REDIRECT = True
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True
X_FRAME_OPTIONS = 'DENY'
SECURE_HSTS_SECONDS = 31536000
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True
SESSION_COOKIE_SECURE = True
CSRF_COOKIE_SECURE = True

# Static files for production
STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'
STATIC_ROOT = BASE_DIR / 'staticfiles'

# Database - use Fly.io Postgres
DATABASES = {
    'default': dj_database_url.parse(env('DATABASE_URL'))
}

# Allowed hosts - update with your Fly.io app name
ALLOWED_HOSTS = [
    'ai-face-swap-app.fly.dev',
    'localhost',
    '127.0.0.1',
]

# CORS settings for your frontend
CORS_ALLOWED_ORIGINS = [
    "https://your-frontend-app.netlify.app",  # Will update after frontend deployment
    "https://ai-face-swap-app.fly.dev",
]

# Add health check URL
from django.urls import path, include
from django.http import JsonResponse

def health_check(request):
    return JsonResponse({"status": "healthy"})

# Add to your main urls.py
# path('health/', health_check, name='health-check'),

# Logging for production
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'root': {
        'handlers': ['console'],
        'level': 'INFO',
    },
    'loggers': {
        'django': {
            'handlers': ['console'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}
```

## django_project/settings/base.py
```python
from environ import Env
from pathlib import Path
import stripe
import os
from django.core.management.utils import get_random_secret_key

print("💥 settings.py loaded from latest build")

# Cloudinary Configuration
import cloudinary
import cloudinary.uploader
import cloudinary.api

# Initialize environment variables
env = Env()

# For build time, provide defaults for all required env vars
cloudinary_url = env('CLOUDINARY_URL', default='')
if cloudinary_url:
    # Parse the cloudinary://api_key:api_secret@cloud_name format
    import re
    match = re.match(r'cloudinary://(\d+):([^@]+)@(.+)', cloudinary_url)
    if match:
        api_key, api_secret, cloud_name = match.groups()
        CLOUDINARY_STORAGE = {
            'CLOUD_NAME': cloud_name,
            'API_KEY': api_key,
            'API_SECRET': api_secret,
        }
        print(f"✅ Cloudinary configured from CLOUDINARY_URL for cloud: {cloud_name}")
    else:
        print("⚠️  Invalid CLOUDINARY_URL format, using fallback")
        CLOUDINARY_STORAGE = {
            'CLOUD_NAME': env('CLOUDINARY_CLOUD_NAME', default='dddye9wli'),
            'API_KEY': env('CLOUDINARY_API_KEY', default='dummy'),
            'API_SECRET': env('CLOUDINARY_API_SECRET', default='dummy'),
        }
else:
    # Fallback to individual environment variables
    CLOUDINARY_STORAGE = {
        'CLOUD_NAME': env('CLOUDINARY_CLOUD_NAME', default='dddye9wli'),
        'API_KEY': env('CLOUDINARY_API_KEY', default='dummy'),
        'API_SECRET': env('CLOUDINARY_API_SECRET', default='dummy'),
    }
    print("⚠️  Using individual Cloudinary env vars")

cloudinary.config(
    cloud_name=CLOUDINARY_STORAGE['CLOUD_NAME'],
    api_key=CLOUDINARY_STORAGE['API_KEY'],
    api_secret=CLOUDINARY_STORAGE['API_SECRET'],
    secure=True
)

# Stripe
STRIPE_PUBLISHABLE_KEY = env('STRIPE_PUBLISHABLE_KEY', default='pk_test_dummy')
STRIPE_SECRET_KEY = env('STRIPE_SECRET_KEY', default='sk_test_dummy')
STRIPE_WEBHOOK_SECRET = env('STRIPE_WEBHOOK_SECRET', default='whsec_dummy')
stripe.api_key = STRIPE_SECRET_KEY

OPENAI_API_KEY = env("OPENAI_API_KEY", default="dummy")

# Base directory
BASE_DIR = Path(__file__).resolve().parent.parent

# Security - use Django's built-in secret key generator for build time
SECRET_KEY = env("DJANGO_SECRET_KEY", default=get_random_secret_key())
DEBUG = env.bool("DJANGO_DEBUG", default=False)
SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")

# Hosts
ALLOWED_HOSTS = env.list("DJANGO_ALLOWED_HOSTS", default=[
    "localhost", "127.0.0.1", "0.0.0.0", "web", "*.fly.dev"
])

# Installed apps
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',  # ✅ This is required for collectstatic
    'cloudinary_storage',
    'cloudinary',

    # Custom apps
    'accounts.apps.AccountsConfig',
    'chat.apps.ChatConfig',
    'faceswap.apps.FaceswapConfig',

    # Third-party
    'django.contrib.sites',
    'allauth',
    'allauth.account',
    'allauth.socialaccount',
    'allauth.socialaccount.providers.google',

    'imagegen',
    'corsheaders',

    'rest_framework',
    'rest_framework.authtoken', 
]

# Middleware
MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'allauth.account.middleware.AccountMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'django_project.urls'

# Templates
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR.parent / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'django_project.wsgi.application'

# Database - provide default for build time
DATABASES = {
    "default": env.db_url("DATABASE_URL", default="sqlite:///tmp/build.db")
}

# Auth
AUTH_USER_MODEL = 'accounts.CustomUser'
AUTHENTICATION_BACKENDS = [
    'django.contrib.auth.backends.ModelBackend',
    'allauth.account.auth_backends.AuthenticationBackend',
]

# Allauth
SITE_ID = env.int("DJANGO_SITE_ID", default=1)
ACCOUNT_AUTHENTICATION_METHOD = 'email'
ACCOUNT_USERNAME_REQUIRED = False
ACCOUNT_EMAIL_REQUIRED = True
ACCOUNT_USER_MODEL_USERNAME_FIELD = "email"
ACCOUNT_EMAIL_VERIFICATION = 'optional'
ACCOUNT_SIGNUP_REDIRECT_URL = '/dashboard/'
LOGIN_REDIRECT_URL = '/accounts/dashboard/'
LOGOUT_REDIRECT_URL = '/'

SOCIALACCOUNT_PROVIDERS = {
    'google': {
        'SCOPE': ['profile', 'email'],
        'AUTH_PARAMS': {'access_type': 'online'},
        'OAUTH_PKCE_ENABLED': True,
        'APP': {
            'client_id': env('GOOGLE_CLIENT_ID', default='test-client-id'),
            'secret': env('GOOGLE_CLIENT_SECRET', default='test-secret'),
            'key': ''
        }
    }
}

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},
    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},
    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},
    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},
]

# Localization
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_TZ = True

# Static files - properly configured for collectstatic
STATIC_URL = "/static/"
STATICFILES_DIRS = [BASE_DIR.parent / "static"] if (BASE_DIR.parent / "static").exists() else []
STATIC_ROOT = BASE_DIR / "staticfiles"
STATICFILES_STORAGE = "whitenoise.storage.CompressedManifestStaticFilesStorage"

# Media
DEFAULT_FILE_STORAGE = 'cloudinary_storage.storage.MediaCloudinaryStorage'

# Staticfiles finders
STATICFILES_FINDERS = [
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
]

# Email
EMAIL_BACKEND = env("EMAIL_BACKEND", default="django.core.mail.backends.locmem.EmailBackend")
EMAIL_HOST = env("EMAIL_HOST", default="smtp.test.com")
EMAIL_PORT = env.int("EMAIL_PORT", default=587)
EMAIL_USE_TLS = env.bool("EMAIL_USE_TLS", default=True)
EMAIL_HOST_USER = env("EMAIL_HOST_USER", default="test@test.com")
EMAIL_HOST_PASSWORD = env("EMAIL_HOST_PASSWORD", default="testpassword")
DEFAULT_FROM_EMAIL = env("DEFAULT_FROM_EMAIL", default="noreply@test.com")

# Security
if not DEBUG:
    SECURE_SSL_REDIRECT = env.bool("DJANGO_SECURE_SSL_REDIRECT", default=True)
    SECURE_HSTS_SECONDS = env.int("DJANGO_SECURE_HSTS_SECONDS", default=2592000)
    SECURE_HSTS_INCLUDE_SUBDOMAINS = env.bool("DJANGO_SECURE_HSTS_INCLUDE_SUBDOMAINS", default=True)
    SECURE_HSTS_PRELOAD = env.bool("DJANGO_SECURE_HSTS_PRELOAD", default=True)
    SESSION_COOKIE_SECURE = env.bool("DJANGO_SESSION_COOKIE_SECURE", default=True)
    CSRF_COOKIE_SECURE = env.bool("DJANGO_CSRF_COOKIE_SECURE", default=True)
else:
    SECURE_SSL_REDIRECT = False
    SECURE_HSTS_SECONDS = 0
    SECURE_HSTS_INCLUDE_SUBDOMAINS = False
    SECURE_HSTS_PRELOAD = False
    SESSION_COOKIE_SECURE = False
    CSRF_COOKIE_SECURE = False

# Other
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.TokenAuthentication',
        'rest_framework.authentication.SessionAuthentication',
    ]
}

HUGGINGFACE_FACESWAP_URL = env('HUGGINGFACE_FACESWAP_URL', 
    default='https://mnraynor90-facefusionfastapi-private.hf.space')

CORS_ALLOWED_ORIGINS = [
    "http://localhost:5173",  # Vite dev server
    "http://127.0.0.1:5173",
    "https://*.netlify.app",  # Will be updated with actual Netlify URL
    "https://*.fly.dev",      # Allow all fly.dev subdomains
]

CORS_ALLOW_CREDENTIALS = True

# Add this line with your other API keys
HUGGINGFACE_API_TOKEN = env("HUGGINGFACE_API_TOKEN", default="dummy")
```

## Dockerfile
```python
# Based on official ageitgey/face_recognition Dockerfile
FROM python:3.10.3-slim-bullseye

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1
ENV DEBIAN_FRONTEND=noninteractive

# Install system dependencies (based on official ageitgey Dockerfile)
RUN apt-get -y update
RUN apt-get install -y --fix-missing \
    build-essential \
    cmake \
    gfortran \
    git \
    wget \
    curl \
    graphicsmagick \
    libgraphicsmagick1-dev \
    libatlas-base-dev \
    libavcodec-dev \
    libavformat-dev \
    libgtk2.0-dev \
    libjpeg-dev \
    liblapack-dev \
    libswscale-dev \
    pkg-config \
    python3-dev \
    python3-numpy \
    software-properties-common \
    libpq-dev \
    zip \
    && apt-get clean && rm -rf /tmp/* /var/tmp/*

# Build and install dlib from source (CRITICAL - this is the official way)
RUN cd ~ && \
    mkdir -p dlib && \
    git clone -b 'v19.9' --single-branch https://github.com/davisking/dlib.git dlib/ && \
    cd dlib/ && \
    python3 setup.py install --yes USE_AVX_INSTRUCTIONS

# Set work directory
WORKDIR /app

# Copy requirements and install Python packages
COPY requirements.txt /app/
RUN pip3 install --upgrade pip wheel

# Install face_recognition and other Python packages
RUN pip3 install face_recognition
RUN pip3 install -r requirements.txt

# Set dummy environment variables for build time
ENV DJANGO_SETTINGS_MODULE=django_project.settings.base
ENV DJANGO_SECRET_KEY=build-time-secret-key
ENV DATABASE_URL=sqlite:///tmp/build.db
ENV CLOUDINARY_CLOUD_NAME=dummy
ENV CLOUDINARY_API_KEY=dummy
ENV CLOUDINARY_API_SECRET=dummy
ENV OPENAI_API_KEY=dummy

# Copy project
COPY . /app/

# Create media directories
RUN mkdir -p /app/media/uploads/selfies
RUN mkdir -p /app/staticfiles

# Try to collect static files (skip if it fails)
RUN python3 manage.py collectstatic --noinput || echo "Collectstatic failed, continuing..."

# Create non-root user for security
RUN adduser --disabled-password --gecos '' appuser
RUN chown -R appuser:appuser /app
USER appuser

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
  CMD python3 -c "import requests; requests.get('http://localhost:8000/health/', timeout=10)" || exit 1

# Default command
CMD ["gunicorn", "--bind", "0.0.0.0:8000", "--workers", "3", "--timeout", "300", "django_project.wsgi:application"]
```
