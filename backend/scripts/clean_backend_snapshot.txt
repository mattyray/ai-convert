# CLEAN BACKEND CODE SNAPSHOT
# Essential files for HuggingFace debugging
# Total files: 40
# Excludes: migrations, tests, media, large JSON files

# ===== CONFIGURATION FILES =====


## requirements.txt
```
# Core
Django==5.1.6
gunicorn==23.0.0
whitenoise==6.9.0
psycopg2-binary==2.9.10

# Environment + security
django-environ==0.12.0
cryptography==44.0.3

# Auth + social login
django-allauth==65.6.0
django-crispy-forms==2.3
crispy-bootstrap5==2024.10
django-extensions==4.1

# Media + storage
cloudinary==1.44.0
django-cloudinary-storage==0.3.0
Pillow==10.0.0

# APIs + HTTP
stripe==12.0.1
openai==1.78.1
httpx==0.28.1
requests==2.32.3
urllib3==2.4.0
certifi==2025.4.26
idna==3.10
charset-normalizer==3.4.2

djangorestframework==3.16.0

# Type + utility
pydantic>=2.6,<2.10
typing_extensions==4.13.0
typing-inspection==0.4.0
pytz==2025.2
tzdata==2025.2

# Optional: Data tools (remove if not used in chat utils)
numpy==2.2.4
pandas==2.2.3
pandas-stubs==2.2.3.250308
python-dateutil==2.9.0.post0
tablib==3.8.0
openpyxl==3.1.5

PyJWT==2.10.1

face-recognition==1.3.0
dlib==20.0.0
cmake==4.0.2

django-cors-headers==4.6.0
gradio-client==1.10.3


dj-database-url==2.1.0

```

## requirements-dev.txt
```
-r requirements.txt

flake8==7.2.0
flake8-bandit==4.1.1
mypy==1.15.0
mypy_extensions==1.1.0
pytest==8.3.5
pytest-django==4.11.1
safety==3.5.0
safety-schemas==0.0.14

```

## docker-compose.yml
```
services:
  # PostgreSQL Database
  db:
    image: postgres:15-alpine
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      POSTGRES_DB: faceswap_db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres_password
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Django Backend
  backend:
    build: 
      context: .
      dockerfile: Dockerfile
    ports:
      - "8002:8000"
    environment:
      - DEBUG=True
      - DJANGO_DEBUG=True
      - DJANGO_SETTINGS_MODULE=django_project.settings.dev
      - DATABASE_URL=postgresql://postgres:postgres_password@db:5432/faceswap_db
      - DJANGO_SECRET_KEY=dev-secret-key-change-in-production
      - DJANGO_ALLOWED_HOSTS=localhost,127.0.0.1,backend,0.0.0.0
      - CLOUDINARY_URL=${CLOUDINARY_URL}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - STRIPE_SECRET_KEY=${STRIPE_SECRET_KEY}
      - STRIPE_PUBLISHABLE_KEY=${STRIPE_PUBLISHABLE_KEY}
      # 🔑 FIXED: Use space name format for Gradio client (not full URL)
      - HUGGINGFACE_SPACE_NAME=${HUGGINGFACE_SPACE_NAME}
      - HUGGINGFACE_API_TOKEN=${HUGGINGFACE_API_TOKEN}
    volumes:
      - .:/app
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    depends_on:
      db:
        condition: service_healthy
    command: ["python", "manage.py", "runserver", "0.0.0.0:8000"]

volumes:
  postgres_data:
  static_volume:
  media_volume:
```

## fly.toml
```
app = "ai-face-swap-app"
primary_region = "ewr"
console_command = "/code/manage.py shell"

[build]

[env]
  PORT = "8000"

[http_service]
  internal_port = 8000
  force_https = true
  auto_start_machines = true
  auto_stop_machines = "stop"
  min_machines_running = 0
  processes = ["app"]

  [http_service.concurrency]
    type = "connections"
    soft_limit = 20
    hard_limit = 25

[[vm]]
  memory = "2gb"
  cpu_kind = "shared"
  cpus = 1

[[statics]]
  guest_path = "/code/static"
  url_prefix = "/static/"

# Postgres internal service (Flycast resolution)
[[services]]
  internal_port = 5432
  protocol = "tcp"
  auto_start_machines = true
  auto_stop_machines = true
  processes = ["app"]

  [services.concurrency]
    type = "connections"
    soft_limit = 20
    hard_limit = 25

  [[services.ports]]
    port = 5432
    handlers = ["pg_tls"]

```

## manage.py
```
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "django_project.settings.dev")
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

```


# ===== PYTHON CODE =====


## accounts/models.py
```python
from django.contrib.auth.models import AbstractBaseUser, PermissionsMixin
from django.db import models
from django.utils import timezone
from django.contrib.auth.base_user import BaseUserManager


class CustomUserManager(BaseUserManager):
    def create_user(self, email, password=None, **extra_fields):
        if not email:
            raise ValueError("The Email field must be set")
        email = self.normalize_email(email)
        user = self.model(email=email, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, email, password, **extra_fields):
        extra_fields.setdefault("is_staff", True)
        extra_fields.setdefault("is_superuser", True)
        if not extra_fields.get("is_staff") or not extra_fields.get("is_superuser"):
            raise ValueError("Superuser must have is_staff=True and is_superuser=True.")
        return self.create_user(email, password, **extra_fields)


class CustomUser(AbstractBaseUser, PermissionsMixin):
    email = models.EmailField(unique=True)
    first_name = models.CharField(max_length=30, blank=True)
    last_name = models.CharField(max_length=30, blank=True)
    is_staff = models.BooleanField(default=False)
    is_active = models.BooleanField(default=True)
    date_joined = models.DateTimeField(default=timezone.now)

    USERNAME_FIELD = "email"
    REQUIRED_FIELDS = []

    objects = CustomUserManager()

    def __str__(self):
        return self.email

```

## accounts/serializers.py
```python
from rest_framework import serializers
from django.contrib.auth import get_user_model

User = get_user_model()


class CustomUserSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True, required=True, min_length=8)

    class Meta:
        model = User
        fields = ["id", "email", "first_name", "last_name", "password"]
        read_only_fields = ["id"]

    def create(self, validated_data):
        user = User.objects.create_user(
            email=validated_data["email"],
            password=validated_data["password"],
            first_name=validated_data.get("first_name", ""),
            last_name=validated_data.get("last_name", "")
        )
        return user

    def update(self, instance, validated_data):
        for attr, value in validated_data.items():
            if attr == "password":
                instance.set_password(value)
            else:
                setattr(instance, attr, value)
        instance.save()
        return instance

```

## accounts/__init__.py
```python

```

## accounts/apps.py
```python
from django.apps import AppConfig


class AccountsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'accounts'

```

## accounts/forms.py
```python
from django.contrib.auth import get_user_model
from django.contrib.auth.forms import UserCreationForm, UserChangeForm

class CustomUserCreationForm(UserCreationForm):
    class Meta:
        model = get_user_model()
        fields = ("email",)  # Remove 'username'

class CustomUserChangeForm(UserChangeForm):
    class Meta:
        model = get_user_model()
        fields = ("email",)  # Remove 'username'

```

## accounts/admin.py
```python
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin
from .models import CustomUser
from .forms import CustomUserCreationForm, CustomUserChangeForm

@admin.register(CustomUser)
class CustomUserAdmin(UserAdmin):
    add_form = CustomUserCreationForm
    form = CustomUserChangeForm
    model = CustomUser

    list_display = ("email", "first_name", "last_name", "is_staff", "is_active")
    list_filter = ("is_staff", "is_active")
    ordering = ("email",)

    fieldsets = (
        (None, {"fields": ("email", "password")}),
        ("Personal Info", {"fields": ("first_name", "last_name")}),
        ("Permissions", {"fields": ("is_staff", "is_active", "groups", "user_permissions")}),
        ("Important dates", {"fields": ("last_login", "date_joined")}),
    )

    add_fieldsets = (
        (None, {
            "classes": ("wide",),
            "fields": ("email", "password1", "password2", "is_staff", "is_active"),
        }),
    )

```

## accounts/api_auth.py
```python
from rest_framework.authtoken.views import ObtainAuthToken
from rest_framework.authtoken.models import Token
from rest_framework.response import Response
from rest_framework import status
from django.contrib.auth import authenticate
from rest_framework.views import APIView
from rest_framework.permissions import AllowAny


class CustomAuthToken(APIView):
    permission_classes = [AllowAny]

    def post(self, request, *args, **kwargs):
        email = request.data.get("email")
        password = request.data.get("password")

        if not email or not password:
            return Response({"error": "Email and password are required."}, status=status.HTTP_400_BAD_REQUEST)

        user = authenticate(request, username=email, password=password)

        if not user:
            return Response({"error": "Invalid credentials."}, status=status.HTTP_400_BAD_REQUEST)

        token, _ = Token.objects.get_or_create(user=user)
        return Response({
            "token": token.key,
            "user_id": user.id,
            "email": user.email,
        })

```

## accounts/urls.py
```python
from django.urls import path
from .views import SignupAPIView, UserProfileAPIView, CustomAuthToken

app_name = "accounts"

urlpatterns = [
    path("signup/", SignupAPIView.as_view(), name="signup"),
    path("me/", UserProfileAPIView.as_view(), name="user-profile"),
    path("login/", CustomAuthToken.as_view(), name="token-login"),
]

```

## accounts/views.py
```python
from rest_framework import generics, permissions, status
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.authtoken.views import ObtainAuthToken
from rest_framework.authtoken.models import Token
from django.contrib.auth import authenticate, get_user_model

from .serializers import CustomUserSerializer

User = get_user_model()


class SignupAPIView(generics.CreateAPIView):
    """
    POST /api/accounts/signup/
    """
    queryset = User.objects.all()
    serializer_class = CustomUserSerializer
    permission_classes = [permissions.AllowAny]


class UserProfileAPIView(APIView):
    """
    GET, PUT /api/accounts/me/
    """
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        serializer = CustomUserSerializer(request.user)
        return Response(serializer.data)

    def put(self, request):
        serializer = CustomUserSerializer(request.user, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class CustomAuthToken(ObtainAuthToken):
    """
    POST /api/accounts/login/
    Authenticates using email and password.
    """
    def post(self, request, *args, **kwargs):
        email = request.data.get("email")
        password = request.data.get("password")

        if not email or not password:
            return Response({"error": "Email and password are required."}, status=status.HTTP_400_BAD_REQUEST)

        user = authenticate(request, email=email, password=password)
        if not user:
            return Response({"error": "Invalid credentials."}, status=status.HTTP_401_UNAUTHORIZED)

        token, created = Token.objects.get_or_create(user=user)
        return Response({"token": token.key})

```

## faceswap/models.py
```python
from django.db import models
from django.contrib.auth import get_user_model

User = get_user_model()

class FaceSwapJob(models.Model):
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('processing', 'Processing'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    source_image = models.ImageField(upload_to='faceswap/source/')
    target_image = models.ImageField(upload_to='faceswap/target/')
    result_image = models.ImageField(upload_to='faceswap/results/', null=True, blank=True)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    error_message = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        ordering = ['-created_at']
    
    def __str__(self):
        return f"FaceSwap Job {self.id} - {self.user.email} - {self.status}"
```

## faceswap/serializers.py
```python
from rest_framework import serializers
from .models import FaceSwapJob

class FaceSwapJobSerializer(serializers.ModelSerializer):
    class Meta:
        model = FaceSwapJob
        fields = ['id', 'source_image', 'target_image', 'result_image', 
                 'status', 'error_message', 'created_at', 'completed_at']
        read_only_fields = ['id', 'result_image', 'status', 'error_message', 
                           'created_at', 'completed_at']

class FaceSwapCreateSerializer(serializers.ModelSerializer):
    class Meta:
        model = FaceSwapJob
        fields = ['source_image', 'target_image']
```

## faceswap/__init__.py
```python

```

## faceswap/apps.py
```python
from django.apps import AppConfig

class FaceswapConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'faceswap'
```

## faceswap/admin.py
```python
from django.contrib import admin
from .models import FaceSwapJob

@admin.register(FaceSwapJob)
class FaceSwapJobAdmin(admin.ModelAdmin):
    list_display = ['id', 'user', 'status', 'created_at', 'completed_at']
    list_filter = ['status', 'created_at']
    search_fields = ['user__email']
    readonly_fields = ['created_at', 'completed_at']
    
    def get_readonly_fields(self, request, obj=None):
        if obj:  # Editing existing object
            return self.readonly_fields + ['user', 'source_image', 'target_image']
        return self.readonly_fields
```

## faceswap/huggingface_utils.py
```python
# faceswap/huggingface_utils.py - IMPROVED VERSION

import requests
import time
from django.conf import settings
from django.core.files.base import ContentFile
import tempfile
import os
import base64
from gradio_client import Client
import random
import threading
import json

# 🔗 HuggingFace Space Configuration - matches environment variables
HUGGINGFACE_SPACE_NAME = getattr(settings, 'HUGGINGFACE_SPACE_NAME', 
                                'mnraynor90/facefusionfastapi-private')

# 🔑 HuggingFace Authentication Token (from environment)
HUGGINGFACE_API_TOKEN = getattr(settings, 'HUGGINGFACE_API_TOKEN', None)

# Export these for use in views
__all__ = ['FaceFusionClient', 'process_face_swap', 'HUGGINGFACE_SPACE_NAME', 'HUGGINGFACE_API_TOKEN']

def validate_huggingface_config():
    """Validate HuggingFace configuration for security and correctness"""
    issues = []
    
    # Check space name format
    if not HUGGINGFACE_SPACE_NAME or '/' not in HUGGINGFACE_SPACE_NAME:
        issues.append("Invalid HUGGINGFACE_SPACE_NAME format. Expected: 'owner/space-name'")
    
    # Check API token
    if not HUGGINGFACE_API_TOKEN or HUGGINGFACE_API_TOKEN in ['dummy', 'your_token_here']:
        issues.append("Missing or invalid HUGGINGFACE_API_TOKEN. Private spaces require authentication.")
    elif not HUGGINGFACE_API_TOKEN.startswith('hf_'):
        issues.append("Invalid HUGGINGFACE_API_TOKEN format. HuggingFace tokens should start with 'hf_'")
    elif len(HUGGINGFACE_API_TOKEN) < 30:
        issues.append("HUGGINGFACE_API_TOKEN appears too short to be valid")
    
    return issues

class FaceFusionClient:
    """
    IMPROVED: Proper Gradio Client for private space with enhanced authentication and validation
    """
    
    def __init__(self):
        self.client = None
        self.space_name = HUGGINGFACE_SPACE_NAME
        self._validate_config()
        
    def _validate_config(self):
        """Validate configuration before attempting connection"""
        issues = validate_huggingface_config()
        if issues:
            raise Exception(f"HuggingFace configuration issues: {'; '.join(issues)}")
    
    def get_client(self):
        """Get authenticated Gradio client for private space with enhanced error handling"""
        if self.client is None:
            try:
                print(f"🔌 Creating authenticated Gradio client for: {self.space_name}")
                print(f"🔑 Token length: {len(HUGGINGFACE_API_TOKEN)} chars")
                
                # Connect to private space with authentication
                self.client = Client(
                    self.space_name,
                    hf_token=HUGGINGFACE_API_TOKEN
                )
                
                print("✅ Authenticated Gradio client created successfully")
                
                # Test the connection by getting API info
                try:
                    api_info = self.client.view_api()
                    print(f"📋 API connection successful")
                    
                    # Check for required endpoints
                    api_str = str(api_info)
                    if '/process_images' in api_str:
                        print("✅ Required /process_images endpoint found")
                    else:
                        print(f"⚠️ /process_images endpoint not found. Available: {api_str[:200]}...")
                        
                except Exception as e:
                    print(f"⚠️ Could not verify API endpoints: {e}")
                
            except Exception as e:
                error_msg = str(e).lower()
                if 'authentication' in error_msg or 'token' in error_msg or 'unauthorized' in error_msg:
                    raise Exception(f"❌ Authentication failed: Invalid or expired HuggingFace API token. Please check your HUGGINGFACE_API_TOKEN")
                elif 'not found' in error_msg or '404' in error_msg:
                    raise Exception(f"❌ Space not found: '{self.space_name}' does not exist or is not accessible")
                elif 'rate limit' in error_msg or 'too many' in error_msg:
                    raise Exception(f"❌ Rate limited: Too many requests to HuggingFace. Please try again later")
                else:
                    raise Exception(f"❌ Failed to create Gradio client: {e}")
                
        return self.client
    
    def test_connection(self):
        """Test connection without performing operations"""
        try:
            client = self.get_client()
            api_info = client.view_api()
            return {
                'status': 'success',
                'space_name': self.space_name,
                'token_valid': True,
                'api_endpoints_available': '/process_images' in str(api_info)
            }
        except Exception as e:
            return {
                'status': 'failed',
                'space_name': self.space_name,
                'token_valid': False,
                'error': str(e)
            }
    
    def get_image_url(self, image_field):
        """Convert Django ImageField to accessible URL"""
        try:
            if hasattr(image_field, 'url'):
                image_url = image_field.url
                
                if image_url.startswith('http'):
                    return image_url
                
                if image_url.startswith('/') and hasattr(image_field, 'name'):
                    try:
                        import cloudinary.utils
                        cloudinary_url = cloudinary.utils.cloudinary_url(image_field.name)[0]
                        print(f"✅ Using Cloudinary URL: {cloudinary_url}")
                        return cloudinary_url
                    except Exception as e:
                        print(f"⚠️ Cloudinary failed: {e}")
                        base_url = getattr(settings, 'BASE_URL', 'http://127.0.0.1:8002')
                        return f"{base_url}{image_url}"
                
                return image_url
            else:
                raise Exception("Invalid image field")
        except Exception as e:
            raise Exception(f"Failed to get image URL: {str(e)}")
    
    def setup_facefusion(self):
        """Setup FaceFusion before processing with retry logic"""
        max_retries = 2
        for attempt in range(max_retries):
            try:
                print(f"🔧 Setting up FaceFusion (attempt {attempt + 1}/{max_retries})...")
                client = self.get_client()
                
                result = client.predict(api_name="/setup_facefusion")
                print(f"✅ Setup complete: {result}")
                return result
                
            except Exception as e:
                print(f"❌ Setup attempt {attempt + 1} failed: {e}")
                if attempt < max_retries - 1:
                    time.sleep(2)
                    self.client = None  # Reset client for retry
                    continue
                raise e
    
    def swap_faces(self, source_image_field, target_image_field, max_retries=3):
        """
        IMPROVED: Use proper Gradio client with enhanced error handling and validation
        """
        # Get URLs
        source_url = self.get_image_url(source_image_field)
        target_url = self.get_image_url(target_image_field)
        
        print(f"🔄 Starting face swap with Gradio client")
        print(f"  Source: {source_url[:80]}...")
        print(f"  Target: {target_url[:80]}...")
        
        for attempt in range(max_retries):
            try:
                print(f"🎭 Face swap attempt {attempt + 1}/{max_retries}")
                
                client = self.get_client()
                
                # Optional: Setup FaceFusion first
                try:
                    self.setup_facefusion()
                except Exception as setup_error:
                    print(f"⚠️ Setup failed: {setup_error}, continuing anyway...")
                
                # Call the correct API endpoint with proper parameters
                result = client.predict(
                    source_url=source_url,  # 👤 Source Image URL (Face to transfer)
                    target_url=target_url,  # 🎯 Target Image URL (Body/scene)
                    api_name="/process_images"
                )
                
                print(f"📋 Gradio result: {type(result)} - {result}")
                
                if not result or len(result) < 2:
                    raise Exception(f"Invalid result format: {result}")
                
                result_filepath = result[0]  # Image file path
                status_message = result[1]   # Status message
                
                print(f"📋 Status: {status_message}")
                print(f"📁 Result file: {result_filepath}")
                
                # Handle the result file path
                if hasattr(result_filepath, 'save'):  # PIL Image
                    print("✅ Got PIL Image, converting to bytes")
                    import io
                    img_buffer = io.BytesIO()
                    result_filepath.save(img_buffer, format='JPEG', quality=90)
                    return img_buffer.getvalue()
                    
                elif isinstance(result_filepath, str) and os.path.exists(result_filepath):  # File path
                    print(f"✅ Got file path: {result_filepath}")
                    with open(result_filepath, 'rb') as f:
                        return f.read()
                        
                elif isinstance(result_filepath, dict):  # Gradio file object
                    if 'path' in result_filepath and os.path.exists(result_filepath['path']):
                        print(f"✅ Got Gradio file object: {result_filepath['path']}")
                        with open(result_filepath['path'], 'rb') as f:
                            return f.read()
                    elif 'url' in result_filepath:
                        print(f"✅ Got URL from Gradio: {result_filepath['url']}")
                        # Download from URL
                        response = requests.get(result_filepath['url'], timeout=60)
                        response.raise_for_status()
                        return response.content
                        
                else:
                    raise Exception(f"Unexpected result format: {type(result_filepath)} - {result_filepath}")
                    
            except Exception as e:
                error_msg = str(e).lower()
                print(f"❌ Face swap attempt {attempt + 1} failed: {e}")
                
                # Handle specific error types
                if 'authentication' in error_msg or 'unauthorized' in error_msg:
                    raise Exception("Authentication failed. Please check your HuggingFace API token.")
                elif 'slow down' in error_msg or 'too many' in error_msg or 'rate limit' in error_msg:
                    print("🚨 Rate limited - resetting client")
                    self.client = None  # Reset client
                    
                    if attempt < max_retries - 1:
                        delay = (2 ** attempt) * 3 + random.uniform(0, 3)
                        print(f"⏳ Waiting {delay:.1f}s...")
                        time.sleep(delay)
                        continue
                    else:
                        raise Exception("Rate limited after all retries")
                
                elif attempt < max_retries - 1:
                    delay = 5 + random.uniform(0, 2)
                    print(f"⏳ Retrying in {delay:.1f}s...")
                    time.sleep(delay)
                    continue
                else:
                    break
        
        raise Exception(f"All face swap attempts failed")

def process_face_swap(job_id):
    """
    Process a face swap job using the improved Gradio client
    """
    from .models import FaceSwapJob
    from django.utils import timezone
    
    try:
        job = FaceSwapJob.objects.get(id=job_id)
        job.status = 'processing'
        job.save()
        
        print(f"🚀 Processing face swap job {job_id} with improved Gradio client")
        
        # Initialize the client
        client = FaceFusionClient()
        
        # Test connection first
        connection_test = client.test_connection()
        if connection_test['status'] != 'success':
            raise Exception(f"Connection test failed: {connection_test['error']}")
        
        # Perform face swap
        result_image_data = client.swap_faces(job.source_image, job.target_image)
        
        # Save result
        result_filename = f"faceswap_result_{job.id}_{int(time.time())}.jpg"
        result_file = ContentFile(result_image_data, name=result_filename)
        job.result_image.save(result_filename, result_file)
        
        # Update status
        job.status = 'completed'
        job.completed_at = timezone.now()
        job.save()
        
        print(f"✅ Face swap job {job_id} completed successfully")
        return True
        
    except FaceSwapJob.DoesNotExist:
        print(f"❌ Face swap job {job_id} not found")
        return False
    except Exception as e:
        print(f"❌ Face swap job {job_id} failed: {e}")
        try:
            job.status = 'failed'
            job.error_message = str(e)
            job.save()
        except:
            pass
        return False
```

## faceswap/urls.py
```python
from django.urls import path
from .views import (
    FaceSwapCreateView,
    FaceSwapListView, 
    FaceSwapDetailView,
    FaceSwapStatusView,
    FaceSwapTestURLView,
    DebugGradioAPIView,
    HuggingFaceDebugView,  # Add this import
    TestGradioConnectionView
)

app_name = "faceswap"

urlpatterns = [
    path("create/", FaceSwapCreateView.as_view(), name="create"),
    path("jobs/", FaceSwapListView.as_view(), name="list"),
    path("jobs/<int:pk>/", FaceSwapDetailView.as_view(), name="detail"),
    path("status/<int:job_id>/", FaceSwapStatusView.as_view(), name="status"),
    path("test-url/", FaceSwapTestURLView.as_view(), name="test-url"),
    path("debug/", DebugGradioAPIView.as_view(), name="debug"),
    path("debug-hf/", HuggingFaceDebugView.as_view(), name="debug-hf"),  # Add this line
    path("test-gradio/", TestGradioConnectionView.as_view(), name="test-gradio"),

]
```

## faceswap/views.py
```python
from rest_framework import generics, status, permissions
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.views import APIView
from django.shortcuts import get_object_or_404
from .models import FaceSwapJob
from .serializers import FaceSwapJobSerializer, FaceSwapCreateSerializer
from .huggingface_utils import process_face_swap
import threading

class FaceSwapCreateView(generics.CreateAPIView):
    """
    POST /api/faceswap/create/
    Upload source and target images to start face swapping
    """
    serializer_class = FaceSwapCreateSerializer
    permission_classes = [IsAuthenticated]
    
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        # Create job with current user
        job = serializer.save(user=request.user)
        
        # Start processing in background thread (or use Celery if available)
        def process_in_background():
            process_face_swap(job.id)
        
        thread = threading.Thread(target=process_in_background)
        thread.daemon = True
        thread.start()
        
        # Return job details
        response_serializer = FaceSwapJobSerializer(job)
        return Response(response_serializer.data, status=status.HTTP_201_CREATED)

class FaceSwapListView(generics.ListAPIView):
    """
    GET /api/faceswap/jobs/
    List all face swap jobs for the current user
    """
    serializer_class = FaceSwapJobSerializer
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        return FaceSwapJob.objects.filter(user=self.request.user)

class FaceSwapDetailView(generics.RetrieveAPIView):
    """
    GET /api/faceswap/jobs/{id}/
    Get details of a specific face swap job
    """
    serializer_class = FaceSwapJobSerializer
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        return FaceSwapJob.objects.filter(user=self.request.user)

class FaceSwapStatusView(APIView):
    """
    GET /api/faceswap/status/{id}/
    Quick status check for a face swap job
    """
    permission_classes = [IsAuthenticated]
    
    def get(self, request, job_id):
        job = get_object_or_404(FaceSwapJob, id=job_id, user=request.user)
        return Response({
            'id': job.id,
            'status': job.status,
            'error_message': job.error_message,
            'result_image': job.result_image.url if job.result_image else None,
            'created_at': job.created_at,
            'completed_at': job.completed_at
        })

class FaceSwapTestURLView(APIView):
    """
    POST /api/faceswap/test-url/
    Test face swapping with direct URLs (for testing with Cloudinary)
    """
    permission_classes = [IsAuthenticated]
    
    def post(self, request):
        source_url = request.data.get('source_url')
        target_url = request.data.get('target_url')
        
        if not source_url or not target_url:
            return Response({
                'error': 'Both source_url and target_url are required'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            from .huggingface_utils import FaceFusionClient
            client = FaceFusionClient()
            
            # Create a simple mock object with url property
            class MockImageField:
                def __init__(self, url):
                    self.url = url
            
            source_mock = MockImageField(source_url)
            target_mock = MockImageField(target_url)
            
            # Test the face swap
            result_data = client.swap_faces(source_mock, target_mock)
            
            # Return base64 encoded result for testing
            import base64
            result_b64 = base64.b64encode(result_data).decode('utf-8')
            
            return Response({
                'status': 'success',
                'message': 'Face swap completed successfully',
                'result_size': len(result_data),
                'result_preview': f"data:image/jpeg;base64,{result_b64[:100]}..."  # First 100 chars
            })
            
        except Exception as e:
            return Response({
                'error': f'Face swap failed: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class DebugGradioAPIView(APIView):
    """
    Debug endpoint to test Gradio Space connectivity
    """
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        try:
            from .huggingface_utils import HUGGINGFACE_SPACE_NAME, HUGGINGFACE_API_TOKEN
            from gradio_client import Client
            import requests
            
            results = {}
            
            # Build the .hf.space URL for testing
            space_parts = HUGGINGFACE_SPACE_NAME.split('/')
            if len(space_parts) == 2:
                direct_url = f"https://{space_parts[0]}-{space_parts[1]}.hf.space"
            else:
                direct_url = "Invalid space name format"
            
            results['configuration'] = {
                'space_name': HUGGINGFACE_SPACE_NAME,
                'direct_url': direct_url,
                'token_configured': bool(HUGGINGFACE_API_TOKEN),
                'token_length': len(HUGGINGFACE_API_TOKEN) if HUGGINGFACE_API_TOKEN else 0
            }
            
            # Test 1: Check if the space is accessible
            try:
                response = requests.get(direct_url, timeout=10)
                results['space_accessibility'] = {
                    'status': f"HTTP {response.status_code}",
                    'accessible': response.status_code == 200,
                    'response_size': len(response.content)
                }
            except Exception as e:
                results['space_accessibility'] = {
                    'status': f"Error: {str(e)}",
                    'accessible': False
                }
            
            # Test 2: Try Gradio client connection
            try:
                client = Client(HUGGINGFACE_SPACE_NAME, hf_token=HUGGINGFACE_API_TOKEN)
                api_info = client.view_api(return_format="dict")
                results['gradio_client'] = {
                    'connection': 'success',
                    'api_endpoints': list(api_info.keys()) if isinstance(api_info, dict) else 'Not a dict',
                    'endpoint_count': len(api_info) if isinstance(api_info, dict) else 0,
                    'has_process_images': '/process_images' in str(api_info)
                }
            except Exception as e:
                results['gradio_client'] = {
                    'connection': 'failed',
                    'error': str(e)
                }
                
            return Response({
                'space_name': HUGGINGFACE_SPACE_NAME,
                'debug_results': results
            })
            
        except Exception as e:
            return Response({
                'error': f'Debug failed: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class HuggingFaceDebugView(APIView):
    """
    Comprehensive debug endpoint to test HuggingFace Space connectivity
    """
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        try:
            from .huggingface_utils import HUGGINGFACE_SPACE_NAME, HUGGINGFACE_API_TOKEN
            from gradio_client import Client
            import requests
            
            results = {}
            
            # Build direct URL from space name
            space_parts = HUGGINGFACE_SPACE_NAME.split('/')
            if len(space_parts) == 2:
                direct_url = f"https://{space_parts[0]}-{space_parts[1]}.hf.space"
            else:
                return Response({
                    'error': f'Invalid space name format: {HUGGINGFACE_SPACE_NAME}. Expected: owner/space-name'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            results['configuration'] = {
                'space_name': HUGGINGFACE_SPACE_NAME,
                'direct_url': direct_url,
                'token_configured': bool(HUGGINGFACE_API_TOKEN)
            }
            
            # Test 1: Basic connectivity
            try:
                print("🔍 Testing basic connectivity...")
                response = requests.get(direct_url, timeout=10)
                results['basic_connectivity'] = {
                    'status': f"HTTP {response.status_code}",
                    'accessible': response.status_code == 200,
                    'response_size': len(response.content)
                }
            except Exception as e:
                results['basic_connectivity'] = {
                    'status': f"Error: {str(e)}",
                    'accessible': False
                }
            
            # Test 2: Gradio Client connection
            try:
                print("🎭 Testing Gradio Client...")
                client = Client(HUGGINGFACE_SPACE_NAME, hf_token=HUGGINGFACE_API_TOKEN)
                
                # Try to get API info
                api_info = client.view_api(return_format="dict")
                results['gradio_client'] = {
                    'connection': 'success',
                    'api_endpoints': list(api_info.keys()) if isinstance(api_info, dict) else 'Not a dict',
                    'endpoint_count': len(api_info) if isinstance(api_info, dict) else 0
                }
                
                # Check if our specific endpoint exists
                if '/process_images' in str(api_info):
                    results['gradio_client']['process_images_available'] = True
                else:
                    results['gradio_client']['process_images_available'] = False
                    results['gradio_client']['available_endpoints'] = str(api_info)[:500]
                
            except Exception as e:
                results['gradio_client'] = {
                    'connection': 'failed',
                    'error': str(e)
                }
            
            # Test 3: Try actual FaceFusion client
            try:
                print("🧪 Testing FaceFusion client...")
                from .huggingface_utils import FaceFusionClient
                client = FaceFusionClient()
                
                # Test setup
                setup_result = client.setup_facefusion()
                results['facefusion_client'] = {
                    'setup': 'success',
                    'setup_result': setup_result
                }
                
            except Exception as e:
                results['facefusion_client'] = {
                    'setup': 'failed',
                    'error': str(e)
                }
            
            # Summary and recommendations
            recommendations = []
            
            if not results.get('basic_connectivity', {}).get('accessible'):
                recommendations.append("❌ Space is not accessible - check if it's running")
            
            if not HUGGINGFACE_API_TOKEN:
                recommendations.append("🔑 No API token provided - add HUGGINGFACE_API_TOKEN")
            
            if results.get('gradio_client', {}).get('connection') == 'failed':
                recommendations.append("🎭 Gradio client connection failed - check space name and token")
            
            if not results.get('gradio_client', {}).get('process_images_available'):
                recommendations.append("📋 process_images endpoint not found - check your Gradio app")
            
            if not recommendations:
                recommendations.append("✅ All tests passed - connection should work!")
            
            return Response({
                'space_name': HUGGINGFACE_SPACE_NAME,
                'direct_url': direct_url,
                'token_configured': bool(HUGGINGFACE_API_TOKEN),
                'test_results': results,
                'recommendations': recommendations
            })
            
        except Exception as e:
            return Response({
                'error': f'Debug failed: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class TestGradioConnectionView(APIView):
    """Enhanced test endpoint with comprehensive validation"""
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        try:
            from django.conf import settings
            from .huggingface_utils import (
                FaceFusionClient, 
                HUGGINGFACE_SPACE_NAME, 
                HUGGINGFACE_API_TOKEN,
                validate_huggingface_config
            )
            
            # Step 1: Validate configuration
            config_issues = validate_huggingface_config()
            
            # Debug environment variables
            debug_info = {
                'space_name_from_settings': getattr(settings, 'HUGGINGFACE_SPACE_NAME', 'NOT_SET'),
                'space_name_from_utils': HUGGINGFACE_SPACE_NAME,
                'api_token_configured': bool(HUGGINGFACE_API_TOKEN and HUGGINGFACE_API_TOKEN != 'dummy'),
                'api_token_length': len(HUGGINGFACE_API_TOKEN) if HUGGINGFACE_API_TOKEN else 0,
                'api_token_format_valid': HUGGINGFACE_API_TOKEN.startswith('hf_') if HUGGINGFACE_API_TOKEN else False,
                'config_issues': config_issues
            }
            
            # If there are configuration issues, return early
            if config_issues:
                return Response({
                    'status': 'configuration_error',
                    'debug_info': debug_info,
                    'recommendations': [
                        '🔧 Fix configuration issues before testing connection',
                        '🔑 Ensure HUGGINGFACE_API_TOKEN is set correctly',
                        '📝 Check HUGGINGFACE_SPACE_NAME format (owner/space-name)'
                    ]
                }, status=status.HTTP_400_BAD_REQUEST)
            
            # Step 2: Test connection
            client = FaceFusionClient()
            connection_test = client.test_connection()
            
            if connection_test['status'] == 'success':
                # Step 3: Try setup if connection works
                try:
                    setup_result = client.setup_facefusion()
                    return Response({
                        'status': 'success',
                        'debug_info': debug_info,
                        'connection_test': connection_test,
                        'setup_result': setup_result,
                        'message': '🎉 All tests passed! Gradio client is ready for use.',
                        'recommendations': [
                            '✅ Configuration is valid',
                            '✅ Authentication successful', 
                            '✅ API endpoints accessible',
                            '✅ Setup completed successfully'
                        ]
                    })
                except Exception as setup_error:
                    return Response({
                        'status': 'setup_failed',
                        'debug_info': debug_info,
                        'connection_test': connection_test,
                        'setup_error': str(setup_error),
                        'message': '⚠️ Connection works but setup failed',
                        'recommendations': [
                            '✅ Authentication successful',
                            '❌ Setup failed - check if the space is running',
                            '🔄 Try again in a few moments'
                        ]
                    })
            else:
                return Response({
                    'status': 'connection_failed',
                    'debug_info': debug_info,
                    'connection_test': connection_test,
                    'recommendations': [
                        '❌ Connection failed',
                        '🔑 Check if API token is valid and not expired',
                        '🏠 Verify space name is correct',
                        '🚀 Ensure space is running and accessible'
                    ]
                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
            
        except Exception as e:
            # Make sure debug_info is available in the error case
            debug_info = {}
            try:
                from django.conf import settings
                from .huggingface_utils import HUGGINGFACE_SPACE_NAME, HUGGINGFACE_API_TOKEN
                debug_info = {
                    'space_name_from_settings': getattr(settings, 'HUGGINGFACE_SPACE_NAME', 'NOT_SET'),
                    'space_name_from_utils': HUGGINGFACE_SPACE_NAME,
                    'api_token_configured': bool(HUGGINGFACE_API_TOKEN and HUGGINGFACE_API_TOKEN != 'dummy'),
                    'api_token_length': len(HUGGINGFACE_API_TOKEN) if HUGGINGFACE_API_TOKEN else 0,
                    'api_token_format_valid': HUGGINGFACE_API_TOKEN.startswith('hf_') if HUGGINGFACE_API_TOKEN else False
                }
            except Exception:
                pass
                
            return Response({
                'status': 'error',
                'debug_info': debug_info,
                'error': str(e),
                'recommendations': [
                    '❌ Unexpected error occurred',
                    '🔍 Check logs for more details',
                    '⚙️ Verify all environment variables are set correctly'
                ]
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
```

## imagegen/models.py
```python
from django.db import models
from django.conf import settings
from cloudinary_storage.storage import MediaCloudinaryStorage

class GeneratedImage(models.Model):
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="generated_images"
    )
    prompt = models.TextField()
    match_name = models.CharField(max_length=100)
    selfie = models.ImageField(
        upload_to="uploads/selfies/",
        storage=MediaCloudinaryStorage()  # ✅ Explicitly use Cloudinary
    )
    output_image = models.ImageField(
        upload_to="uploads/fused/", 
        null=True, 
        blank=True,
        storage=MediaCloudinaryStorage()  # ✅ Explicitly use Cloudinary
    )
    output_url = models.URLField(blank=True, default="")
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.match_name} - {self.created_at.strftime('%Y-%m-%d %H:%M')}"
```

## imagegen/serializers.py
```python
from rest_framework import serializers
from .models import GeneratedImage

class GeneratedImageSerializer(serializers.ModelSerializer):
    class Meta:
        model = GeneratedImage
        fields = '__all__'
        read_only_fields = ['id', 'created_at', 'user']

```

## imagegen/face_match.py
```python
import face_recognition
import numpy as np
import json
from pathlib import Path

EMBEDDINGS_PATH = Path(__file__).resolve().parent.parent / "face_data" / "embeddings.json"

def match_face(uploaded_image_path):
    """
    Match an uploaded face image against historical figures
    Returns best match with confidence score
    """
    try:
        print(f"🔍 Processing uploaded image: {uploaded_image_path}")
        
        # Load the uploaded selfie
        image = face_recognition.load_image_file(uploaded_image_path)
        face_locations = face_recognition.face_locations(image)
        
        if not face_locations:
            return {"error": "No face detected in uploaded image."}
        
        if len(face_locations) > 1:
            print(f"⚠️  Multiple faces detected, using the largest one.")
        
        # Get encoding for the uploaded face
        uploaded_encoding = face_recognition.face_encodings(image, known_face_locations=face_locations)[0]
        print(f"✅ Successfully extracted face encoding from uploaded image")
        
    except Exception as e:
        print(f"❌ Error processing uploaded image: {str(e)}")
        return {"error": f"Failed to process uploaded image: {e}"}

    # Load historical figure embeddings
    try:
        if not EMBEDDINGS_PATH.exists():
            return {"error": f"Embeddings file not found at {EMBEDDINGS_PATH}. Run embed_cloudinary_faces.py first."}
            
        with open(EMBEDDINGS_PATH, "r") as f:
            known_embeddings = json.load(f)
            
        if not known_embeddings:
            return {"error": "No historical embeddings found. Run embed_cloudinary_faces.py first."}
            
        print(f"📚 Loaded {len(known_embeddings)} historical figure embeddings")
        
    except Exception as e:
        print(f"❌ Error loading embeddings: {str(e)}")
        return {"error": f"Failed to load historical embeddings: {e}"}

    # Compare using cosine similarity
    def cosine_similarity(a, b):
        """Calculate cosine similarity between two vectors"""
        return np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))

    best_match = None
    best_score = -1
    all_scores = []

    print("🎯 Comparing against historical figures...")
    
    for entry in known_embeddings:
        try:
            name = entry["name"]
            known_vector = np.array(entry["embedding"])
            
            # Calculate similarity score
            score = cosine_similarity(uploaded_encoding, known_vector)
            all_scores.append((name, score))
            
            print(f"  • {name}: {score:.3f}")
            
            if score > best_score:
                best_score = score
                best_match = name
                
        except Exception as e:
            print(f"⚠️  Error processing {entry.get('name', 'unknown')}: {str(e)}")
            continue

    # Sort all scores for debugging
    all_scores.sort(key=lambda x: x[1], reverse=True)
    print(f"\n🏆 Top 3 matches:")
    for i, (name, score) in enumerate(all_scores[:3]):
        print(f"  {i+1}. {name}: {score:.3f}")

    if best_match and best_score > 0.3:  # Minimum confidence threshold
        print(f"\n✅ Best match: {best_match} (confidence: {best_score:.3f})")
        return {
            "match_name": best_match, 
            "score": best_score,
            "all_matches": all_scores[:5]  # Return top 5 for debugging
        }
    else:
        print(f"\n❌ No confident match found (best score: {best_score:.3f})")
        return {
            "error": f"No confident match found. Best match was {best_match} with score {best_score:.3f}",
            "all_matches": all_scores[:5]
        }
```

## imagegen/__init__.py
```python

```

## imagegen/apps.py
```python
from django.apps import AppConfig


class ImagegenConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'imagegen'

```

## imagegen/admin.py
```python
from django.contrib import admin
from .models import GeneratedImage

@admin.register(GeneratedImage)
class GeneratedImageAdmin(admin.ModelAdmin):
    list_display = ('match_name', 'user', 'created_at')
    readonly_fields = ('created_at',)

```

## imagegen/urls.py
```python
from django.urls import path
from .views import GenerateImageView, ImageStatusView, UnlockImageView, ListGeneratedImagesView

urlpatterns = [
    path("generate/", GenerateImageView.as_view(), name="generate-image"),
    path("status/<int:prediction_id>/", ImageStatusView.as_view(), name="image-status"),
    path("unlock/", UnlockImageView.as_view(), name="unlock-generation"),
    path("list/", ListGeneratedImagesView.as_view(), name="list-images"),  # New endpoint
]
```

## imagegen/views.py
```python
# imagegen/views.py - Updated with 65+ historical figures

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status, permissions
from .models import GeneratedImage
from .face_match import match_face
from faceswap.huggingface_utils import FaceFusionClient  # Use the fixed client!
import tempfile
import base64
from django.core.files.base import ContentFile
import os
from django.core.files.uploadedfile import InMemoryUploadedFile
import io
import time
import random

# Map historical figures to their Cloudinary URLs - UPDATED WITH 65+ FIGURES
# Generated from Cloudinary root level
# Copy this dict to your Django views.py

HISTORICAL_FIGURES = {
    "Abraham Lincoln": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608917/Abraham_Lincoln_o5kbjh.png",
    "Alexander the Great": "https://res.cloudinary.com/dddye9wli/image/upload/v1749854959/alexander_the_great_j5icxu.png",
    "Andy Warhol": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608920/Andy_Warhol_p6lq5q.png",
    "Anne Frank": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608918/Anne_Frank_flivyh.png",
    "Audrey Hepburn": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608919/Audrey_Hepburn_rtw37d.png",
    "Benjamin Franklin": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608919/Benjamin_Franklin_lh9vdd.png",
    "Beyonce": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608922/Beyonce_ry9nep.png",
    "Bill Clinton": "https://res.cloudinary.com/dddye9wli/image/upload/v1750374687/Bill_Clinton_za0jbh.png",
    "Billie Holiday": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608922/Billie_Holiday_zpq9ks.png",
    "Bob Dylan": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608922/Bob_Dylan_soy4se.png",
    "Brittany Spears": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608923/Brittany_Spears_kdhdh3.png",
    "Che Guevara": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921229/Che_Guevara_kkrtcr.png",
    "Cher": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608926/cher_hhhcbg.png",
    "Christopher Columbus": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608926/Christopher_columbus_oewf7p.png",
    "Cleopatra": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921359/cleopatra_zcslcx.png",
    "Coco Chanel": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921232/Coco_Chanel_dw4bcq.png",
    "Danny Devito": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608926/Danny_Devito_ajkoal.png",
    "Donald Trump": "https://res.cloudinary.com/dddye9wli/image/upload/v1750550608/Donald_Trump_yqggmn.png",
    "Elon Musk": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608926/Elon_Musk_c3ii8i.png",
    "Elvis": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921841/elvis_heazqa.png", #god dammit
    "Elvisnotsinging": "https://res.cloudinary.com/dddye9wli/image/upload/v1749857225/elvisnotsinging_twnnta.png",
    "Frida Khalo": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921232/frida_khalo_gzibma.png",
    "Genghis Khan": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608927/Genghis_Khan_ewsfvk.png",
    "Hernan Cortes": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608930/Hernan_Cortes_lfonsp.png",
    "JFK": "https://res.cloudinary.com/dddye9wli/image/upload/v1749856600/jfk_npw3lg.png",
    "James Dean": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921232/james_dean_bhaaum.png",
    "Janis Joplin": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608930/Janis_Joplin_cl5pi8.png",
    "Jimi Hendrix": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921237/jimi_hendrix_fm56df.png",
    "Joan of Arc": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921237/Joan_of_Arc_bysrio.png",
    "John Lennon": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608930/John_Lennon_lod1zc.png",
    "Josephine Baker": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608930/Josephine_Baker_spiswe.png",
    "Judy Garland": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608931/Judy_Garland_bfbss2.png",
    "Julius Cesear": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608931/Julius_Cesear_wampoh.png",
    "Karl Marx": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608934/Karl_Marx_hlmk0s.png",
    "Keith": "https://res.cloudinary.com/dddye9wli/image/upload/v1749856455/keith_o6fgff.png",
    "King Henry Vii": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608935/King_Henry_VII_wpclza.png",
    "Kylie Jenner": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608935/Kylie_Jenner_vwasob.png",
    "Leonardo da Vinci": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921238/leonardo_davinci_wpggcn.png",
    "Lucille Ball": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608935/Lucille_Ball_a5zjih.png",
    "Madonna": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608935/Madonna_qlszs5.png",
    "Malcolm X": "https://res.cloudinary.com/dddye9wli/image/upload/v1749854991/malcolm_x_kwlnil.png",
    "Mao Zedong": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608935/Mao_zedong_lpvr7v.png",
    "Marco Polo": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608937/Marco_Polo_mah3wb.png",
    "Marie Antoinette": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921242/Marie_Antoinette_f6ndp6.png",
    "Marilyn Manson": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608936/Marilyn_Manson_zwe6f7.png",
    "Marilyn Monroe": "https://res.cloudinary.com/dddye9wli/image/upload/v1749858269/marilyn_monroe_zhaxku.png",
    "Mark Zuckerberg": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608936/Mark_Zuckerberg_tvctxl.png",
    "Mona Lisa": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608976/Mona_Lisa_cwnwdk.png",
    "Napolean": "https://res.cloudinary.com/dddye9wli/image/upload/v1749742732/napolean_azenei.png",
    "Oprah Winfrey": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608983/oprah_winfrey_c24nib.png",
    "Paula Dean": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608987/Paula_Dean_lmyabz.png",
    "Pocahontas": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921243/Pocahontas_ys39zg.png",
    "Princess Diana": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921243/princess_diana_xcvc2a.png",
    "Queen Elizabeth I": "https://res.cloudinary.com/dddye9wli/image/upload/v1750608993/Queen_Elizabeth_I_ct6ku4.png",
    "Queen Victoria": "https://res.cloudinary.com/dddye9wli/image/upload/v1750609003/Queen_Victoria_jq4b9h.png",
    "Ragnar Lothbrok": "https://res.cloudinary.com/dddye9wli/image/upload/v1750609005/Ragnar_Lothbrok_mwwutr.png",
    "Rasputin": "https://res.cloudinary.com/dddye9wli/image/upload/v1750609008/Rasputin_kcpdi4.png",
    "Richard Nixon": "https://res.cloudinary.com/dddye9wli/image/upload/v1750609008/Richard_Nixon_qfgsnz.png",
    "Sigourney Weaver": "https://res.cloudinary.com/dddye9wli/image/upload/v1750609007/Sigourney_Weaver_vn70qg.png",
    "Steve Jobs": "https://res.cloudinary.com/dddye9wli/image/upload/v1750609007/Steve_Jobs_gluiyu.png",
    "Susan B Anthony": "https://res.cloudinary.com/dddye9wli/image/upload/v1750609008/Susan_B_Anthony_pgeomw.png",
    "Vladimir Putin": "https://res.cloudinary.com/dddye9wli/image/upload/v1750609009/Vladimir_Putin_u3k1st.png",
    "Xi Jinping": "https://res.cloudinary.com/dddye9wli/image/upload/v1750609010/Xi_Jinping_tiyqx2.png",
    "Yoko Ono": "https://res.cloudinary.com/dddye9wli/image/upload/v1750609010/Yoco_ono_ttzyo1.png",
}



class GenerateImageView(APIView):
    permission_classes = [permissions.AllowAny]

    def post(self, request):
        selfie = request.FILES.get("selfie")
        if not selfie:
            return Response({"error": "Selfie is required"}, status=status.HTTP_400_BAD_REQUEST)

        # Read the file content once and store it
        selfie_content = selfie.read()
        
        # Save uploaded selfie to temporary file for face matching
        with tempfile.NamedTemporaryFile(delete=False, suffix=".jpg") as tmp:
            tmp.write(selfie_content)
            tmp_path = tmp.name

        # Create a new file object for Django model (reset file pointer)
        selfie_for_model = InMemoryUploadedFile(
            file=io.BytesIO(selfie_content),
            field_name=selfie.field_name,
            name=selfie.name,
            content_type=selfie.content_type,
            size=len(selfie_content),
            charset=selfie.charset,
        )

        temp_image = None
        try:
            # Step 1: Match face with historical figures
            print("🔍 Starting face matching...")
            match_result = match_face(tmp_path)
            if "error" in match_result:
                return Response(match_result, status=status.HTTP_400_BAD_REQUEST)

            match_name = match_result["match_name"]
            match_score = match_result.get("score", 0)
            
            print(f"🎯 Face match found: {match_name} (score: {match_score:.3f})")

            # Check if we have a historical image for this match
            historical_image_url = HISTORICAL_FIGURES.get(match_name)
            if not historical_image_url:
                return Response({
                    "error": f"No historical image available for {match_name}. Available figures: {list(HISTORICAL_FIGURES.keys())}"
                }, status=status.HTTP_400_BAD_REQUEST)

            # Step 2: Create database record with the fresh file object
            temp_image = GeneratedImage.objects.create(
                user=request.user if request.user.is_authenticated else None,
                prompt=f"You as {match_name}",
                match_name=match_name,
                selfie=selfie_for_model,
                output_url="",
            )

            print(f"📝 Created GeneratedImage record: {temp_image.id}")

            # Step 3: Create mock image field objects for face swap
            class MockImageField:
                def __init__(self, url):
                    self.url = url

            source_mock = MockImageField(temp_image.selfie.url)  # User's selfie
            target_mock = MockImageField(historical_image_url)   # Historical figure

            print(f"🔄 Starting face swap: {temp_image.selfie.url} -> {historical_image_url}")

            # Step 4: Use the FIXED Gradio client approach
            client = FaceFusionClient()
            result_image_data = client.swap_faces(source_mock, target_mock)

            print(f"✅ Face swap completed: {len(result_image_data)} bytes")

            # Step 5: Save the result
            temp_image.output_image.save(
                f"{temp_image.id}_fused_{match_name.replace(' ', '_')}.jpg", 
                ContentFile(result_image_data)
            )
            temp_image.save()

            print(f"💾 Saved result to: {temp_image.output_image.url}")

            return Response({
                "id": temp_image.id,
                "match_name": match_name,
                "match_score": round(match_score, 3),
                "message": f"Successfully transformed you into {match_name}!",
                "output_image_url": temp_image.output_image.url,
                "original_selfie_url": temp_image.selfie.url,
                "historical_figure_url": historical_image_url
            })

        except Exception as e:
            print(f"❌ Error in GenerateImageView: {str(e)}")
            # Clean up on error
            if temp_image:
                try:
                    temp_image.delete()
                except:
                    pass
            
            return Response({
                "error": f"Face processing failed: {str(e)}"
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
        finally:
            # Clean up temporary file
            try:
                os.unlink(tmp_path)
            except:
                pass


class ImageStatusView(APIView):
    """Get status of a generated image"""
    def get(self, request, prediction_id):
        try:
            generated_image = GeneratedImage.objects.get(id=prediction_id)
            
            return Response({
                "id": generated_image.id,
                "status": "completed" if generated_image.output_image else "processing",
                "match_name": generated_image.match_name,
                "prompt": generated_image.prompt,
                "output_image_url": generated_image.output_image.url if generated_image.output_image else None,
                "created_at": generated_image.created_at
            })
        except GeneratedImage.DoesNotExist:
            return Response(
                {"error": "Generated image not found"}, 
                status=status.HTTP_404_NOT_FOUND
            )


class UnlockImageView(APIView):
    """Reset generation counter for demo purposes"""
    def post(self, request):
        request.session["image_generation_count"] = 0
        return Response({"message": "Unlock granted. You can generate again."})


class ListGeneratedImagesView(APIView):
    """List all generated images for a user"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        images = GeneratedImage.objects.filter(user=request.user).order_by('-created_at')
        
        results = []
        for img in images:
            results.append({
                "id": img.id,
                "match_name": img.match_name,
                "prompt": img.prompt,
                "output_image_url": img.output_image.url if img.output_image else None,
                "selfie_url": img.selfie.url,
                "created_at": img.created_at
            })
        
        return Response({"images": results})
```

## django_project/asgi.py
```python
"""
ASGI config for django_project project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django_project.settings.prod')

application = get_asgi_application()

```

## django_project/__init__.py
```python

```

## django_project/urls.py
```python
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static
from django.http import JsonResponse

def api_root(request):
    return JsonResponse({"message": "API is running!"})

def health_check(request):
    return JsonResponse({"status": "healthy"})

urlpatterns = [
    path("", api_root),
    path("health/", health_check, name="health-check"),  # Add this line
    path("admin/", admin.site.urls),
    path("api/accounts/", include(("accounts.urls", "accounts"), namespace="accounts")),
    path("api/chat/", include(("chat.urls", "chat"), namespace="chat")),
    path("api/imagegen/", include("imagegen.urls")),
    path("api/faceswap/", include(("faceswap.urls", "faceswap"), namespace="faceswap")),
]

if settings.DEBUG:
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
```

## django_project/wsgi.py
```python
"""
WSGI config for django_project project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django_project.settings.prod')

application = get_wsgi_application()

```

## django_project/settings/__init__.py
```python

```

## django_project/settings/test.py
```python
from .base import *

DEBUG = False
SECRET_KEY = "test-secret-key"

STRIPE_PUBLISHABLE_KEY = "pk_test_dummy"
STRIPE_SECRET_KEY = "sk_test_dummy"
STRIPE_WEBHOOK_SECRET = "whsec_dummy"
stripe.api_key = STRIPE_SECRET_KEY



EMAIL_BACKEND = "django.core.mail.backends.locmem.EmailBackend"
EMAIL_HOST = "localhost"
EMAIL_PORT = 1025
EMAIL_USE_TLS = False
EMAIL_HOST_USER = ""
EMAIL_HOST_PASSWORD = ""
DEFAULT_FROM_EMAIL = "test@example.com"


# In-memory test DB
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "test.sqlite3",
    }
}

RECAPTCHA_PUBLIC_KEY = "test"
RECAPTCHA_PRIVATE_KEY = "test"

# 👇 Google SSO override here only for tests
SOCIALACCOUNT_PROVIDERS = {
    'google': {
        'SCOPE': ['profile', 'email'],
        'AUTH_PARAMS': {'access_type': 'online'},
        'OAUTH_PKCE_ENABLED': True,
        'APP': {
            'client_id': 'test-client-id',
            'secret': 'test-secret',
            'key': ''
        }
    }
}

SECURE_SSL_REDIRECT = False
SECURE_HSTS_SECONDS = 0
SECURE_HSTS_INCLUDE_SUBDOMAINS = False
SECURE_HSTS_PRELOAD = False
SESSION_COOKIE_SECURE = False
CSRF_COOKIE_SECURE = False

```

## django_project/settings/dev.py
```python
# backend/django_project/settings/dev.py
from .base import *

DEBUG = True

# Database for local development
DATABASES = {
    "default": env.db_url("DATABASE_URL", default="postgresql://postgres:postgres_password@db:5432/faceswap_db")
}

# Add localhost to allowed hosts
ALLOWED_HOSTS = env.list("DJANGO_ALLOWED_HOSTS", default=[
    "localhost", "127.0.0.1", "0.0.0.0", "backend"
])

# CORS settings for local development
CORS_ALLOWED_ORIGINS = [
    "http://localhost:5173",  # Vite dev server
    "http://127.0.0.1:5173",
]
```

## django_project/settings/prod.py
```python
# django_project/settings/prod.py - IMPROVED WITH DATABASE ERROR HANDLING
from .base import *
import os
import sys
import dj_database_url
from django.core.exceptions import ImproperlyConfigured

DEBUG = False

# ---------------- SECURITY ----------------
SECURE_SSL_REDIRECT = True
SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")
SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True
X_FRAME_OPTIONS = "DENY"
SECURE_HSTS_SECONDS = 31536000
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True
SESSION_COOKIE_SECURE = True
CSRF_COOKIE_SECURE = True

# ---------------- STATIC FILES ----------------
STATICFILES_STORAGE = "whitenoise.storage.CompressedManifestStaticFilesStorage"
STATIC_ROOT = BASE_DIR / "staticfiles"

# ---------------- DATABASE (IMPROVED ERROR HANDLING) ----------------
DATABASE_URL = os.environ.get("DATABASE_URL")

if DATABASE_URL:
    try:
        print(f"🔍 Raw DATABASE_URL: {DATABASE_URL[:50]}...", file=sys.stderr)
        
        parsed = dj_database_url.parse(
            DATABASE_URL,
            conn_max_age=600,
            conn_health_checks=True,
        )
        
        # Add engine if missing
        if "ENGINE" not in parsed:
            parsed["ENGINE"] = "django.db.backends.postgresql"
        
        print(f"✅ DEBUG: Parsed DATABASE_URL → {parsed}", file=sys.stderr)
        
        # 🔥 FIX: Handle empty database name (common Fly.io issue)
        if not parsed.get("NAME") or parsed.get("NAME") == "":
            # Try to extract database name from the app name
            app_name = os.environ.get("FLY_APP_NAME", "ai-face-swap-app")
            # Remove the "-app" suffix if present for database name
            db_name = app_name.replace("-app", "")
            parsed["NAME"] = db_name
            print(f"🔧 Fixed empty database name: using '{db_name}'", file=sys.stderr)
        
        # Validate all required database fields
        required_fields = ["ENGINE", "NAME", "USER", "HOST", "PORT"]
        missing_fields = [field for field in required_fields if not parsed.get(field)]
        
        if missing_fields:
            print(f"❌ Missing database fields: {missing_fields}", file=sys.stderr)
            raise ImproperlyConfigured(f"Missing database configuration fields: {missing_fields}")
        
        DATABASES = {"default": parsed}
        print(f"✅ Database configured successfully: {parsed['NAME']}@{parsed['HOST']}", file=sys.stderr)
        
    except Exception as e:
        print(f"❌ Database configuration error: {e}", file=sys.stderr)
        print(f"Raw DATABASE_URL was: {DATABASE_URL}", file=sys.stderr)
        
        # 🔥 FALLBACK: Try manual parsing if dj_database_url fails
        if "postgres://" in DATABASE_URL or "postgresql://" in DATABASE_URL:
            print("🔧 Attempting manual DATABASE_URL parsing...", file=sys.stderr)
            try:
                import re
                # Parse postgres://user:password@host:port/database
                match = re.match(r'postgres(?:ql)?://([^:]+):([^@]+)@([^:]+):(\d+)/(.+)', DATABASE_URL)
                if match:
                    user, password, host, port, database = match.groups()
                    # Remove query parameters if present
                    database = database.split('?')[0]
                    
                    DATABASES = {
                        "default": {
                            "ENGINE": "django.db.backends.postgresql",
                            "NAME": database,
                            "USER": user,
                            "PASSWORD": password,
                            "HOST": host,
                            "PORT": int(port),
                            "CONN_MAX_AGE": 600,
                            "CONN_HEALTH_CHECKS": True,
                        }
                    }
                    print(f"✅ Manual parsing successful: {database}@{host}", file=sys.stderr)
                else:
                    raise Exception("Could not parse DATABASE_URL format")
            except Exception as manual_error:
                print(f"❌ Manual parsing also failed: {manual_error}", file=sys.stderr)
                raise ImproperlyConfigured(f"Could not configure database: {e}")
        else:
            raise ImproperlyConfigured(f"Invalid DATABASE_URL format: {e}")
else:
    print("❌ No DATABASE_URL environment variable found", file=sys.stderr)
    raise ImproperlyConfigured("DATABASE_URL environment variable is required in production")

# ---------------- HOSTS ----------------
# Get app name from Fly.io environment
FLY_APP_NAME = os.environ.get("FLY_APP_NAME", "ai-face-swap-app")

ALLOWED_HOSTS = [
    f"{FLY_APP_NAME}.fly.dev",
    "ai-face-swap-app.fly.dev",
    "localhost",
    "127.0.0.1",
]

# Add custom allowed hosts from environment
custom_hosts = os.environ.get("DJANGO_ALLOWED_HOSTS", "")
if custom_hosts:
    ALLOWED_HOSTS.extend([host.strip() for host in custom_hosts.split(",") if host.strip()])

CSRF_TRUSTED_ORIGINS = [
    f"https://{FLY_APP_NAME}.fly.dev",
    "https://ai-face-swap-app.fly.dev",
]

# CORS for frontend
CORS_ALLOWED_ORIGINS = [
    f"https://{FLY_APP_NAME}.fly.dev",
    "https://ai-face-swap-app.fly.dev",
]

# ---------------- LOGGING (IMPROVED) ----------------
LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "verbose": {
            "format": "{levelname} {asctime} {module} {process:d} {thread:d} {message}",
            "style": "{",
        },
    },
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "verbose",
        },
    },
    "root": {
        "handlers": ["console"],
        "level": "INFO",
    },
    "loggers": {
        "django": {
            "handlers": ["console"],
            "level": "INFO",
            "propagate": False,
        },
        "django.db.backends": {
            "handlers": ["console"],
            "level": "DEBUG",
            "propagate": False,
        },
    },
}

print(f"✅ Production settings loaded for {FLY_APP_NAME}", file=sys.stderr)
```

## django_project/settings/base.py
```python
from environ import Env
from pathlib import Path
import stripe
import os
from django.core.management.utils import get_random_secret_key

print("💥 settings.py loaded from latest build")

# Cloudinary Configuration
import cloudinary
import cloudinary.uploader
import cloudinary.api

# Initialize environment variables
env = Env()

# For build time, provide defaults for all required env vars
cloudinary_url = env('CLOUDINARY_URL', default='')
if cloudinary_url:
    # Parse the cloudinary://api_key:api_secret@cloud_name format
    import re
    match = re.match(r'cloudinary://(\d+):([^@]+)@(.+)', cloudinary_url)
    if match:
        api_key, api_secret, cloud_name = match.groups()
        CLOUDINARY_STORAGE = {
            'CLOUD_NAME': cloud_name,
            'API_KEY': api_key,
            'API_SECRET': api_secret,
        }
        print(f"✅ Cloudinary configured from CLOUDINARY_URL for cloud: {cloud_name}")
    else:
        print("⚠️  Invalid CLOUDINARY_URL format, using fallback")
        CLOUDINARY_STORAGE = {
            'CLOUD_NAME': env('CLOUDINARY_CLOUD_NAME', default='dddye9wli'),
            'API_KEY': env('CLOUDINARY_API_KEY', default='dummy'),
            'API_SECRET': env('CLOUDINARY_API_SECRET', default='dummy'),
        }
else:
    # Fallback to individual environment variables
    CLOUDINARY_STORAGE = {
        'CLOUD_NAME': env('CLOUDINARY_CLOUD_NAME', default='dddye9wli'),
        'API_KEY': env('CLOUDINARY_API_KEY', default='dummy'),
        'API_SECRET': env('CLOUDINARY_API_SECRET', default='dummy'),
    }
    print("⚠️  Using individual Cloudinary env vars")

cloudinary.config(
    cloud_name=CLOUDINARY_STORAGE['CLOUD_NAME'],
    api_key=CLOUDINARY_STORAGE['API_KEY'],
    api_secret=CLOUDINARY_STORAGE['API_SECRET'],
    secure=True
)

# Stripe
STRIPE_PUBLISHABLE_KEY = env('STRIPE_PUBLISHABLE_KEY', default='pk_test_dummy')
STRIPE_SECRET_KEY = env('STRIPE_SECRET_KEY', default='sk_test_dummy')
STRIPE_WEBHOOK_SECRET = env('STRIPE_WEBHOOK_SECRET', default='whsec_dummy')
stripe.api_key = STRIPE_SECRET_KEY

OPENAI_API_KEY = env("OPENAI_API_KEY", default="dummy")

# Base directory
BASE_DIR = Path(__file__).resolve().parent.parent

# Security - use Django's built-in secret key generator for build time
SECRET_KEY = env("DJANGO_SECRET_KEY", default=get_random_secret_key())
DEBUG = env.bool("DJANGO_DEBUG", default=False)
SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")

# Hosts
ALLOWED_HOSTS = env.list("DJANGO_ALLOWED_HOSTS", default=[
    "localhost", "127.0.0.1", "0.0.0.0", "web", "*.fly.dev"
])

# Installed apps
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',  # ✅ This is required for collectstatic
    'cloudinary_storage',
    'cloudinary',

    # Custom apps
    'accounts.apps.AccountsConfig',
    'chat.apps.ChatConfig',
    'faceswap.apps.FaceswapConfig',

    # Third-party
    'django.contrib.sites',
    'allauth',
    'allauth.account',
    'allauth.socialaccount',
    'allauth.socialaccount.providers.google',

    'imagegen',
    'corsheaders',

    'rest_framework',
    'rest_framework.authtoken', 
]

# Middleware
MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'allauth.account.middleware.AccountMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'django_project.urls'

# Templates
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR.parent / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'django_project.wsgi.application'

# Database - provide default for build time
DATABASES = {
    "default": env.db_url("DATABASE_URL", default="sqlite:///tmp/build.db")
}

# Auth
AUTH_USER_MODEL = 'accounts.CustomUser'
AUTHENTICATION_BACKENDS = [
    'django.contrib.auth.backends.ModelBackend',
    'allauth.account.auth_backends.AuthenticationBackend',
]

# Allauth
SITE_ID = env.int("DJANGO_SITE_ID", default=1)
ACCOUNT_AUTHENTICATION_METHOD = 'email'
ACCOUNT_USERNAME_REQUIRED = False
ACCOUNT_EMAIL_REQUIRED = True
ACCOUNT_USER_MODEL_USERNAME_FIELD = "email"
ACCOUNT_EMAIL_VERIFICATION = 'optional'
ACCOUNT_SIGNUP_REDIRECT_URL = '/dashboard/'
LOGIN_REDIRECT_URL = '/accounts/dashboard/'
LOGOUT_REDIRECT_URL = '/'

SOCIALACCOUNT_PROVIDERS = {
    'google': {
        'SCOPE': ['profile', 'email'],
        'AUTH_PARAMS': {'access_type': 'online'},
        'OAUTH_PKCE_ENABLED': True,
        'APP': {
            'client_id': env('GOOGLE_CLIENT_ID', default='test-client-id'),
            'secret': env('GOOGLE_CLIENT_SECRET', default='test-secret'),
            'key': ''
        }
    }
}

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},
    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},
    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},
    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},
]

# Localization
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_TZ = True

# Static files - properly configured for collectstatic
STATIC_URL = "/static/"
STATICFILES_DIRS = [BASE_DIR.parent / "static"] if (BASE_DIR.parent / "static").exists() else []
STATIC_ROOT = BASE_DIR / "staticfiles"
STATICFILES_STORAGE = "whitenoise.storage.CompressedManifestStaticFilesStorage"

# Media
DEFAULT_FILE_STORAGE = 'cloudinary_storage.storage.MediaCloudinaryStorage'

# Staticfiles finders
STATICFILES_FINDERS = [
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
]

# Email
EMAIL_BACKEND = env("EMAIL_BACKEND", default="django.core.mail.backends.locmem.EmailBackend")
EMAIL_HOST = env("EMAIL_HOST", default="smtp.test.com")
EMAIL_PORT = env.int("EMAIL_PORT", default=587)
EMAIL_USE_TLS = env.bool("EMAIL_USE_TLS", default=True)
EMAIL_HOST_USER = env("EMAIL_HOST_USER", default="test@test.com")
EMAIL_HOST_PASSWORD = env("EMAIL_HOST_PASSWORD", default="testpassword")
DEFAULT_FROM_EMAIL = env("DEFAULT_FROM_EMAIL", default="noreply@test.com")

# Security
if not DEBUG:
    SECURE_SSL_REDIRECT = env.bool("DJANGO_SECURE_SSL_REDIRECT", default=True)
    SECURE_HSTS_SECONDS = env.int("DJANGO_SECURE_HSTS_SECONDS", default=2592000)
    SECURE_HSTS_INCLUDE_SUBDOMAINS = env.bool("DJANGO_SECURE_HSTS_INCLUDE_SUBDOMAINS", default=True)
    SECURE_HSTS_PRELOAD = env.bool("DJANGO_SECURE_HSTS_PRELOAD", default=True)
    SESSION_COOKIE_SECURE = env.bool("DJANGO_SESSION_COOKIE_SECURE", default=True)
    CSRF_COOKIE_SECURE = env.bool("DJANGO_CSRF_COOKIE_SECURE", default=True)
else:
    SECURE_SSL_REDIRECT = False
    SECURE_HSTS_SECONDS = 0
    SECURE_HSTS_INCLUDE_SUBDOMAINS = False
    SECURE_HSTS_PRELOAD = False
    SESSION_COOKIE_SECURE = False
    CSRF_COOKIE_SECURE = False

# Other
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.TokenAuthentication',
        'rest_framework.authentication.SessionAuthentication',
    ]
}

# HuggingFace Configuration - FIXED
# 🔑 Use space name format (not full URL) for Gradio client
HUGGINGFACE_SPACE_NAME = env('HUGGINGFACE_SPACE_NAME', default='mnraynor90/facefusionfastapi-private')
HUGGINGFACE_API_TOKEN = env("HUGGINGFACE_API_TOKEN", default="dummy")

print(f"🔧 HuggingFace Space: {HUGGINGFACE_SPACE_NAME}")
print(f"🔑 HuggingFace Token: {'***configured***' if HUGGINGFACE_API_TOKEN != 'dummy' else 'NOT SET'}")

CORS_ALLOWED_ORIGINS = [
    "http://localhost:5173",  # Vite dev server
    "http://127.0.0.1:5173",
    "https://*.netlify.app",  # Will be updated with actual Netlify URL
    "https://*.fly.dev",      # Allow all fly.dev subdomains
]

CORS_ALLOW_CREDENTIALS = True


```

## Dockerfile
```python
# Based on official ageitgey/face_recognition Dockerfile
FROM python:3.10.3-slim-bullseye

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1
ENV DEBIAN_FRONTEND=noninteractive

# Install system dependencies (based on official ageitgey Dockerfile)
RUN apt-get -y update
RUN apt-get install -y --fix-missing \
    build-essential \
    cmake \
    gfortran \
    git \
    wget \
    curl \
    graphicsmagick \
    libgraphicsmagick1-dev \
    libatlas-base-dev \
    libavcodec-dev \
    libavformat-dev \
    libgtk2.0-dev \
    libjpeg-dev \
    liblapack-dev \
    libswscale-dev \
    pkg-config \
    python3-dev \
    python3-numpy \
    software-properties-common \
    libpq-dev \
    zip \
    && apt-get clean && rm -rf /tmp/* /var/tmp/*

# Build and install dlib from source (CRITICAL - this is the official way)
RUN cd ~ && \
    mkdir -p dlib && \
    git clone -b 'v19.9' --single-branch https://github.com/davisking/dlib.git dlib/ && \
    cd dlib/ && \
    python3 setup.py install --yes USE_AVX_INSTRUCTIONS

# Set work directory
WORKDIR /app

# Copy requirements and install Python packages
COPY requirements.txt /app/
RUN pip3 install --upgrade pip wheel

# Install face_recognition and other Python packages
RUN pip3 install face_recognition
RUN pip3 install -r requirements.txt

# Set dummy environment variables for build time (FIXED: Added HuggingFace vars)
ENV DJANGO_SETTINGS_MODULE=django_project.settings.base
ENV DJANGO_SECRET_KEY=build-time-secret-key
ENV DATABASE_URL=sqlite:///tmp/build.db
ENV CLOUDINARY_CLOUD_NAME=dummy
ENV CLOUDINARY_API_KEY=dummy
ENV CLOUDINARY_API_SECRET=dummy
ENV OPENAI_API_KEY=dummy
ENV HUGGINGFACE_SPACE_NAME=mnraynor90/facefusionfastapi-private

# Copy project
COPY . /app/

# Create media directories
RUN mkdir -p /app/media/uploads/selfies
RUN mkdir -p /app/staticfiles

# Try to collect static files (skip if it fails)
RUN python3 manage.py collectstatic --noinput || echo "Collectstatic failed, continuing..."

# Create non-root user for security
RUN adduser --disabled-password --gecos '' appuser
RUN chown -R appuser:appuser /app
USER appuser

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
  CMD python3 -c "import requests; requests.get('http://localhost:8000/health/', timeout=10)" || exit 1

# Default command
CMD ["gunicorn", "--bind", "0.0.0.0:8000", "--workers", "3", "--timeout", "300", "django_project.wsgi:application"]
```
