

# ==== accounts/models.py ====

from django.contrib.auth.models import AbstractBaseUser, PermissionsMixin
from django.db import models
from django.utils import timezone
from django.contrib.auth.base_user import BaseUserManager


class CustomUserManager(BaseUserManager):
    def create_user(self, email, password=None, **extra_fields):
        if not email:
            raise ValueError("The Email field must be set")
        email = self.normalize_email(email)
        user = self.model(email=email, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, email, password, **extra_fields):
        extra_fields.setdefault("is_staff", True)
        extra_fields.setdefault("is_superuser", True)
        if not extra_fields.get("is_staff") or not extra_fields.get("is_superuser"):
            raise ValueError("Superuser must have is_staff=True and is_superuser=True.")
        return self.create_user(email, password, **extra_fields)


class CustomUser(AbstractBaseUser, PermissionsMixin):
    email = models.EmailField(unique=True)
    first_name = models.CharField(max_length=30, blank=True)
    last_name = models.CharField(max_length=30, blank=True)
    is_staff = models.BooleanField(default=False)
    is_active = models.BooleanField(default=True)
    date_joined = models.DateTimeField(default=timezone.now)

    USERNAME_FIELD = "email"
    REQUIRED_FIELDS = []

    objects = CustomUserManager()

    def __str__(self):
        return self.email




# ==== accounts/serializers.py ====

from rest_framework import serializers
from django.contrib.auth import get_user_model

User = get_user_model()


class CustomUserSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True, required=True, min_length=8)

    class Meta:
        model = User
        fields = ["id", "email", "first_name", "last_name", "password"]
        read_only_fields = ["id"]

    def create(self, validated_data):
        user = User.objects.create_user(
            email=validated_data["email"],
            password=validated_data["password"],
            first_name=validated_data.get("first_name", ""),
            last_name=validated_data.get("last_name", "")
        )
        return user

    def update(self, instance, validated_data):
        for attr, value in validated_data.items():
            if attr == "password":
                instance.set_password(value)
            else:
                setattr(instance, attr, value)
        instance.save()
        return instance




# ==== accounts/__init__.py ====





# ==== accounts/apps.py ====

from django.apps import AppConfig


class AccountsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'accounts'




# ==== accounts/forms.py ====

from django.contrib.auth import get_user_model
from django.contrib.auth.forms import UserCreationForm, UserChangeForm

class CustomUserCreationForm(UserCreationForm):
    class Meta:
        model = get_user_model()
        fields = ("email",)  # Remove 'username'

class CustomUserChangeForm(UserChangeForm):
    class Meta:
        model = get_user_model()
        fields = ("email",)  # Remove 'username'




# ==== accounts/admin.py ====

from django.contrib import admin
from django.contrib.auth.admin import UserAdmin
from .models import CustomUser
from .forms import CustomUserCreationForm, CustomUserChangeForm

@admin.register(CustomUser)
class CustomUserAdmin(UserAdmin):
    add_form = CustomUserCreationForm
    form = CustomUserChangeForm
    model = CustomUser

    list_display = ("email", "first_name", "last_name", "is_staff", "is_active")
    list_filter = ("is_staff", "is_active")
    ordering = ("email",)

    fieldsets = (
        (None, {"fields": ("email", "password")}),
        ("Personal Info", {"fields": ("first_name", "last_name")}),
        ("Permissions", {"fields": ("is_staff", "is_active", "groups", "user_permissions")}),
        ("Important dates", {"fields": ("last_login", "date_joined")}),
    )

    add_fieldsets = (
        (None, {
            "classes": ("wide",),
            "fields": ("email", "password1", "password2", "is_staff", "is_active"),
        }),
    )




# ==== accounts/api_auth.py ====

from rest_framework.authtoken.views import ObtainAuthToken
from rest_framework.authtoken.models import Token
from rest_framework.response import Response
from rest_framework import status
from django.contrib.auth import authenticate
from rest_framework.views import APIView
from rest_framework.permissions import AllowAny


class CustomAuthToken(APIView):
    permission_classes = [AllowAny]

    def post(self, request, *args, **kwargs):
        email = request.data.get("email")
        password = request.data.get("password")

        if not email or not password:
            return Response({"error": "Email and password are required."}, status=status.HTTP_400_BAD_REQUEST)

        user = authenticate(request, username=email, password=password)

        if not user:
            return Response({"error": "Invalid credentials."}, status=status.HTTP_400_BAD_REQUEST)

        token, _ = Token.objects.get_or_create(user=user)
        return Response({
            "token": token.key,
            "user_id": user.id,
            "email": user.email,
        })




# ==== accounts/tests.py ====

from django.test import TestCase

# Create your tests here.




# ==== accounts/urls.py ====

from django.urls import path
from .views import SignupAPIView, UserProfileAPIView, CustomAuthToken

app_name = "accounts"

urlpatterns = [
    path("signup/", SignupAPIView.as_view(), name="signup"),
    path("me/", UserProfileAPIView.as_view(), name="user-profile"),
    path("login/", CustomAuthToken.as_view(), name="token-login"),
]




# ==== accounts/views.py ====

from rest_framework import generics, permissions, status
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.authtoken.views import ObtainAuthToken
from rest_framework.authtoken.models import Token
from django.contrib.auth import authenticate, get_user_model

from .serializers import CustomUserSerializer

User = get_user_model()


class SignupAPIView(generics.CreateAPIView):
    """
    POST /api/accounts/signup/
    """
    queryset = User.objects.all()
    serializer_class = CustomUserSerializer
    permission_classes = [permissions.AllowAny]


class UserProfileAPIView(APIView):
    """
    GET, PUT /api/accounts/me/
    """
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        serializer = CustomUserSerializer(request.user)
        return Response(serializer.data)

    def put(self, request):
        serializer = CustomUserSerializer(request.user, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class CustomAuthToken(ObtainAuthToken):
    """
    POST /api/accounts/login/
    Authenticates using email and password.
    """
    def post(self, request, *args, **kwargs):
        email = request.data.get("email")
        password = request.data.get("password")

        if not email or not password:
            return Response({"error": "Email and password are required."}, status=status.HTTP_400_BAD_REQUEST)

        user = authenticate(request, email=email, password=password)
        if not user:
            return Response({"error": "Invalid credentials."}, status=status.HTTP_401_UNAUTHORIZED)

        token, created = Token.objects.get_or_create(user=user)
        return Response({"token": token.key})




# ==== accounts/tests/test_placeholder.py ====





# ==== accounts/tests/__init__.py ====





# ==== chat/knowledge_base.py ====

# chat/knowledge_base.py

KNOWLEDGE_BASE = """
About Matthew:
- Matthew Raynor is a C5–C6 quadriplegic living in a nursing home, working toward independent living.
- He’s a former deep-sea fisherman turned web developer, author, and artist.
- He offers services including: custom website development, drone photography, and motivational content.

Web Development:
- Matthew builds full-stack apps using Django, React, PostgreSQL, and Docker.
- Visit the Portfolio to see his projects and the Store to buy his visual memoir.

Drone Services:
- Matthew offers custom drone photography and aerial video shoots.
- Ideal for real estate, landscapes, art installations, and events.

Support:
- Users can support Matthew by donating to his fundraiser, sharing his story, or helping him find housing and caregiving.
- Visit the Contact page to get in touch.

Using the Website:
- Log in or sign up with email or Google.
- Visit the Store to view and purchase artwork or his book.
- Use the Contact form for questions or project inquiries.
- The blog contains reflections, updates, and inspirational writing.

AI Assistant:
- This assistant can help answer questions about Matthew, his journey, services, store, or how to help.
"""




# ==== chat/models.py ====

from django.db import models

# Create your models here.




# ==== chat/__init__.py ====





# ==== chat/apps.py ====

#chat/apps.py
from django.apps import AppConfig


class ChatConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'chat'




# ==== chat/openai_utils.py ====

from pathlib import Path
import json
from django.conf import settings
from openai import OpenAI

client = OpenAI(api_key=settings.OPENAI_API_KEY)

def load_knowledge_base():
    """
    Loads all JSON files from chat/data/ into a combined list.
    Each file should contain either a list or a single dict.
    """
    base_path = Path(settings.BASE_DIR) / "chat" / "data"
    knowledge = []

    for file in base_path.glob("*.json"):
        try:
            data = json.load(file.open())
            if isinstance(data, list):
                knowledge.extend(data)
            elif isinstance(data, dict):
                knowledge.append(data)
        except Exception as e:
            print(f"Error loading {file.name}: {e}")
    return knowledge

def get_openai_response(user_message):
    """
    Constructs a system prompt using the loaded knowledge base
    and sends a user message to OpenAI.
    """
    context_blocks = load_knowledge_base()
    system_content = "You are a helpful assistant on MatthewRaynor.com. Use the following context when answering questions:\n\n"

    for block in context_blocks:
        title = block.get('title') or 'Untitled'
        content = block.get('content') or ''
        system_content += f"- {title}: {content}\n"

    response = client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": system_content},
            {"role": "user", "content": user_message}
        ]
    )
    return response.choices[0].message.content.strip()




# ==== chat/admin.py ====

from django.contrib import admin

# Register your models here.




# ==== chat/tests.py ====

from django.test import TestCase

# Create your tests here.




# ==== chat/urls.py ====

from django.urls import path
from .views import ChatAPIView

app_name = "chat"

urlpatterns = [
    path("ask/", ChatAPIView.as_view(), name="ask"),
]




# ==== chat/views.py ====

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.conf import settings
from openai import OpenAI
from .openai_utils import get_openai_response

client = OpenAI(api_key=settings.OPENAI_API_KEY)


class ChatAPIView(APIView):
    """
    POST /api/chat/ask/
    Accepts a user message and returns an AI-generated reply using OpenAI.
    """

    def post(self, request, *args, **kwargs):
        message = request.data.get("message", "")
        if not message:
            return Response({"error": "Message is required"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            reply = get_openai_response(message)
            return Response({"reply": reply}, status=status.HTTP_200_OK)
        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)




# ==== chat/tests/__init__.py ====





# ==== imagegen/models.py ====

from django.db import models
from django.conf import settings
from cloudinary_storage.storage import MediaCloudinaryStorage

class GeneratedImage(models.Model):
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="generated_images"
    )
    prompt = models.TextField()
    match_name = models.CharField(max_length=100)
    selfie = models.ImageField(
        upload_to="uploads/selfies/",
        storage=MediaCloudinaryStorage()  # ✅ Explicitly use Cloudinary
    )
    output_image = models.ImageField(
        upload_to="uploads/fused/", 
        null=True, 
        blank=True,
        storage=MediaCloudinaryStorage()  # ✅ Explicitly use Cloudinary
    )
    output_url = models.URLField(blank=True, default="")
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.match_name} - {self.created_at.strftime('%Y-%m-%d %H:%M')}"



# ==== imagegen/hf_utils.py ====

import requests

HF_API_URL = "https://mnraynor90-gradiowapi.hf.space/run/predict"

def facefusion_via_hf(selfie_url, target_url):
    try:
        response = requests.post(HF_API_URL, json={
            "data": [selfie_url, target_url]
        }, timeout=300)

        if response.status_code != 200:
            return {"error": f"HF API returned {response.status_code}: {response.text}"}

        data = response.json()
        if "data" in data and data["data"]:
            return {"base64": data["data"][0]}
        return {"error": "Unexpected Hugging Face response format."}

    except Exception as e:
        return {"error": f"FaceFusion API error: {e}"}




# ==== imagegen/serializers.py ====

from rest_framework import serializers
from .models import GeneratedImage

class GeneratedImageSerializer(serializers.ModelSerializer):
    class Meta:
        model = GeneratedImage
        fields = '__all__'
        read_only_fields = ['id', 'created_at', 'user']




# ==== imagegen/face_match.py ====

import face_recognition
import numpy as np
import json
from pathlib import Path

EMBEDDINGS_PATH = Path(__file__).resolve().parent.parent / "face_data" / "embeddings.json"

def match_face(uploaded_image_path):
    """
    Match an uploaded face image against historical figures
    Returns best match with confidence score
    """
    try:
        print(f"🔍 Processing uploaded image: {uploaded_image_path}")
        
        # Load the uploaded selfie
        image = face_recognition.load_image_file(uploaded_image_path)
        face_locations = face_recognition.face_locations(image)
        
        if not face_locations:
            return {"error": "No face detected in uploaded image."}
        
        if len(face_locations) > 1:
            print(f"⚠️  Multiple faces detected, using the largest one.")
        
        # Get encoding for the uploaded face
        uploaded_encoding = face_recognition.face_encodings(image, known_face_locations=face_locations)[0]
        print(f"✅ Successfully extracted face encoding from uploaded image")
        
    except Exception as e:
        print(f"❌ Error processing uploaded image: {str(e)}")
        return {"error": f"Failed to process uploaded image: {e}"}

    # Load historical figure embeddings
    try:
        if not EMBEDDINGS_PATH.exists():
            return {"error": f"Embeddings file not found at {EMBEDDINGS_PATH}. Run embed_cloudinary_faces.py first."}
            
        with open(EMBEDDINGS_PATH, "r") as f:
            known_embeddings = json.load(f)
            
        if not known_embeddings:
            return {"error": "No historical embeddings found. Run embed_cloudinary_faces.py first."}
            
        print(f"📚 Loaded {len(known_embeddings)} historical figure embeddings")
        
    except Exception as e:
        print(f"❌ Error loading embeddings: {str(e)}")
        return {"error": f"Failed to load historical embeddings: {e}"}

    # Compare using cosine similarity
    def cosine_similarity(a, b):
        """Calculate cosine similarity between two vectors"""
        return np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))

    best_match = None
    best_score = -1
    all_scores = []

    print("🎯 Comparing against historical figures...")
    
    for entry in known_embeddings:
        try:
            name = entry["name"]
            known_vector = np.array(entry["embedding"])
            
            # Calculate similarity score
            score = cosine_similarity(uploaded_encoding, known_vector)
            all_scores.append((name, score))
            
            print(f"  • {name}: {score:.3f}")
            
            if score > best_score:
                best_score = score
                best_match = name
                
        except Exception as e:
            print(f"⚠️  Error processing {entry.get('name', 'unknown')}: {str(e)}")
            continue

    # Sort all scores for debugging
    all_scores.sort(key=lambda x: x[1], reverse=True)
    print(f"\n🏆 Top 3 matches:")
    for i, (name, score) in enumerate(all_scores[:3]):
        print(f"  {i+1}. {name}: {score:.3f}")

    if best_match and best_score > 0.3:  # Minimum confidence threshold
        print(f"\n✅ Best match: {best_match} (confidence: {best_score:.3f})")
        return {
            "match_name": best_match, 
            "score": best_score,
            "all_matches": all_scores[:5]  # Return top 5 for debugging
        }
    else:
        print(f"\n❌ No confident match found (best score: {best_score:.3f})")
        return {
            "error": f"No confident match found. Best match was {best_match} with score {best_score:.3f}",
            "all_matches": all_scores[:5]
        }



# ==== imagegen/__init__.py ====





# ==== imagegen/apps.py ====

from django.apps import AppConfig


class ImagegenConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'imagegen'




# ==== imagegen/admin.py ====

from django.contrib import admin
from .models import GeneratedImage

@admin.register(GeneratedImage)
class GeneratedImageAdmin(admin.ModelAdmin):
    list_display = ('match_name', 'user', 'created_at')
    readonly_fields = ('created_at',)




# ==== imagegen/tests.py ====

from django.test import TestCase

# Create your tests here.




# ==== imagegen/urls.py ====

from django.urls import path
from .views import GenerateImageView, ImageStatusView, UnlockImageView, ListGeneratedImagesView

urlpatterns = [
    path("generate/", GenerateImageView.as_view(), name="generate-image"),
    path("status/<int:prediction_id>/", ImageStatusView.as_view(), name="image-status"),
    path("unlock/", UnlockImageView.as_view(), name="unlock-generation"),
    path("list/", ListGeneratedImagesView.as_view(), name="list-images"),  # New endpoint
]



# ==== imagegen/views.py ====

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status, permissions
from .models import GeneratedImage
from .face_match import match_face
from faceswap.huggingface_utils import FaceFusionClient  # Import your working face swap client
import tempfile
import base64
from django.core.files.base import ContentFile
import os
from django.core.files.uploadedfile import InMemoryUploadedFile
import io

# Map historical figures to their Cloudinary URLs
HISTORICAL_FIGURES = {
    "Princess Diana": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921365/princess_diana_ueb9ha.png",
    "Marilyn Monroe": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921365/marilyn_monroe_geys6v.png",
    "Pocahontas": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921365/Pocahontas_kp0obo.png",
    "Napoleon": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921365/napolean_ukozvo.png",
    "Marie Antoinette": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921363/Marie_Antoinette_fvjtgy.png",
    "Keith Haring": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921362/keith_k7b5xw.png",
    "Malcolm X": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921362/malcolm_x_a8sluo.png",
    "Jimi Hendrix": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921362/jimi_hendrix_u07bvu.png",
    "Joan of Arc": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921362/Joan_of_Arc_vvi28l.png",
    "Leonardo da Vinci": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921362/leonardo_davinci_lv7gy8.png",
    "Cleopatra": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921359/cleopatra_zcslcx.png",
    "Frida Kahlo": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921358/frida_khalo_wq6qyl.png",
    "JFK": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921358/jfk_rznzq0.png",
    "James Dean": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921358/james_dean_wvmc5c.png",
    "Coco Chanel": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921358/Coco_Chanel_mnx6s9.png",
    "Elvis Presley": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921841/elvis_heazqa.png",
    "Che Guevara": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921355/Che_Guevara_n8nmln.png",
    "Alexander the Great": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921354/alexander_the_great_mcdwpy.png",
}

class GenerateImageView(APIView):
    permission_classes = [permissions.AllowAny]

    def post(self, request):
        selfie = request.FILES.get("selfie")
        if not selfie:
            return Response({"error": "Selfie is required"}, status=status.HTTP_400_BAD_REQUEST)

        # Read the file content once and store it
        selfie_content = selfie.read()
        
        # Save uploaded selfie to temporary file for face matching
        with tempfile.NamedTemporaryFile(delete=False, suffix=".jpg") as tmp:
            tmp.write(selfie_content)
            tmp_path = tmp.name

        # Create a new file object for Django model (reset file pointer)
        selfie_for_model = InMemoryUploadedFile(
            file=io.BytesIO(selfie_content),
            field_name=selfie.field_name,
            name=selfie.name,
            content_type=selfie.content_type,
            size=len(selfie_content),
            charset=selfie.charset,
        )

        try:
            # Step 1: Match face with historical figures
            match_result = match_face(tmp_path)
            if "error" in match_result:
                return Response(match_result, status=status.HTTP_400_BAD_REQUEST)

            match_name = match_result["match_name"]
            match_score = match_result.get("score", 0)
            
            print(f"🎯 Face match found: {match_name} (score: {match_score:.3f})")

            # Check if we have a historical image for this match
            historical_image_url = HISTORICAL_FIGURES.get(match_name)
            if not historical_image_url:
                return Response({
                    "error": f"No historical image available for {match_name}. Available figures: {list(HISTORICAL_FIGURES.keys())}"
                }, status=status.HTTP_400_BAD_REQUEST)

            # Step 2: Create database record with the fresh file object
            temp_image = GeneratedImage.objects.create(
                user=request.user if request.user.is_authenticated else None,
                prompt=f"You as {match_name}",
                match_name=match_name,
                selfie=selfie_for_model,  # Use the fresh file object
                output_url="",
            )

            print(f"📝 Created GeneratedImage record: {temp_image.id}")

            # Step 3: Create mock image field objects for face swap
            class MockImageField:
                def __init__(self, url):
                    self.url = url

            source_mock = MockImageField(temp_image.selfie.url)  # User's selfie
            target_mock = MockImageField(historical_image_url)   # Historical figure

            print(f"🔄 Starting face swap: {temp_image.selfie.url} -> {historical_image_url}")

            # Step 4: Perform face swap using your working client
            fusion_client = FaceFusionClient()
            result_image_data = fusion_client.swap_faces(source_mock, target_mock)

            print(f"✅ Face swap completed: {len(result_image_data)} bytes")

            # Step 5: Save the result
            temp_image.output_image.save(
                f"{temp_image.id}_fused_{match_name.replace(' ', '_')}.jpg", 
                ContentFile(result_image_data)
            )
            temp_image.save()

            print(f"💾 Saved result to: {temp_image.output_image.url}")

            return Response({
                "id": temp_image.id,
                "match_name": match_name,
                "match_score": round(match_score, 3),
                "message": f"Successfully transformed you into {match_name}!",
                "output_image_url": temp_image.output_image.url,
                "original_selfie_url": temp_image.selfie.url,
                "historical_figure_url": historical_image_url
            })

        except Exception as e:
            print(f"❌ Error in GenerateImageView: {str(e)}")
            # Clean up on error
            try:
                temp_image.delete()
            except:
                pass
            
            return Response({
                "error": f"Face processing failed: {str(e)}"
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
        finally:
            # Clean up temporary file
            try:
                os.unlink(tmp_path)
            except:
                pass


class ImageStatusView(APIView):
    """Get status of a generated image"""
    def get(self, request, prediction_id):
        try:
            generated_image = GeneratedImage.objects.get(id=prediction_id)
            
            return Response({
                "id": generated_image.id,
                "status": "completed" if generated_image.output_image else "processing",
                "match_name": generated_image.match_name,
                "prompt": generated_image.prompt,
                "output_image_url": generated_image.output_image.url if generated_image.output_image else None,
                "created_at": generated_image.created_at
            })
        except GeneratedImage.DoesNotExist:
            return Response(
                {"error": "Generated image not found"}, 
                status=status.HTTP_404_NOT_FOUND
            )


class UnlockImageView(APIView):
    """Reset generation counter for demo purposes"""
    def post(self, request):
        request.session["image_generation_count"] = 0
        return Response({"message": "Unlock granted. You can generate again."})


class ListGeneratedImagesView(APIView):
    """List all generated images for a user"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        images = GeneratedImage.objects.filter(user=request.user).order_by('-created_at')
        
        results = []
        for img in images:
            results.append({
                "id": img.id,
                "match_name": img.match_name,
                "prompt": img.prompt,
                "output_image_url": img.output_image.url if img.output_image else None,
                "selfie_url": img.selfie.url,
                "created_at": img.created_at
            })
        
        return Response({"images": results})



# ==== django_project/asgi.py ====

"""
ASGI config for django_project project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django_project.settings.prod')

application = get_asgi_application()




# ==== django_project/__init__.py ====





# ==== django_project/urls.py ====

from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static
from django.http import JsonResponse

def api_root(request):
    return JsonResponse({"message": "API is running!"})

urlpatterns = [
    path("", api_root),  # ✅ Root path now responds
    path("admin/", admin.site.urls),
    path("api/accounts/", include(("accounts.urls", "accounts"), namespace="accounts")),
    path("api/chat/", include(("chat.urls", "chat"), namespace="chat")),
    path("api/imagegen/", include("imagegen.urls")),  # ✅ Changed from "api/image/" to "api/imagegen/"
    path("api/faceswap/", include(("faceswap.urls", "faceswap"), namespace="faceswap")),
]

if settings.DEBUG:
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)



# ==== django_project/wsgi.py ====

"""
WSGI config for django_project project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django_project.settings.prod')

application = get_wsgi_application()




# ==== django_project/settings/__init__.py ====





# ==== django_project/settings/test.py ====

from .base import *

DEBUG = False
SECRET_KEY = "test-secret-key"

STRIPE_PUBLISHABLE_KEY = "pk_test_dummy"
STRIPE_SECRET_KEY = "sk_test_dummy"
STRIPE_WEBHOOK_SECRET = "whsec_dummy"
stripe.api_key = STRIPE_SECRET_KEY



EMAIL_BACKEND = "django.core.mail.backends.locmem.EmailBackend"
EMAIL_HOST = "localhost"
EMAIL_PORT = 1025
EMAIL_USE_TLS = False
EMAIL_HOST_USER = ""
EMAIL_HOST_PASSWORD = ""
DEFAULT_FROM_EMAIL = "test@example.com"


# In-memory test DB
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "test.sqlite3",
    }
}

RECAPTCHA_PUBLIC_KEY = "test"
RECAPTCHA_PRIVATE_KEY = "test"

# 👇 Google SSO override here only for tests
SOCIALACCOUNT_PROVIDERS = {
    'google': {
        'SCOPE': ['profile', 'email'],
        'AUTH_PARAMS': {'access_type': 'online'},
        'OAUTH_PKCE_ENABLED': True,
        'APP': {
            'client_id': 'test-client-id',
            'secret': 'test-secret',
            'key': ''
        }
    }
}

SECURE_SSL_REDIRECT = False
SECURE_HSTS_SECONDS = 0
SECURE_HSTS_INCLUDE_SUBDOMAINS = False
SECURE_HSTS_PRELOAD = False
SESSION_COOKIE_SECURE = False
CSRF_COOKIE_SECURE = False




# ==== django_project/settings/dev.py ====

from .base import *

DEBUG = True

# Use Stripe test key or fallback
STRIPE_PUBLISHABLE_KEY = env("STRIPE_PUBLISHABLE_KEY", default="pk_test_dummy")
STRIPE_SECRET_KEY = env("STRIPE_SECRET_KEY", default="sk_test_dummy")
STRIPE_WEBHOOK_SECRET = env("STRIPE_WEBHOOK_SECRET", default="whsec_dummy")

stripe.api_key = STRIPE_SECRET_KEY




# ==== django_project/settings/prod.py ====

from .base import *
import dj_database_url

DEBUG = False

# Security settings for production
SECURE_SSL_REDIRECT = True
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True
X_FRAME_OPTIONS = 'DENY'
SECURE_HSTS_SECONDS = 31536000
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True

# Static files for production
STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'
STATIC_ROOT = BASE_DIR / 'staticfiles'

# Database - use Fly.io Postgres
DATABASES = {
    'default': dj_database_url.parse(env('DATABASE_URL'))
}

# Allowed hosts - update with your Fly.io app name
ALLOWED_HOSTS = [
    'your-faceswap-app.fly.dev',  # Replace with your actual app name
    'localhost',
    '127.0.0.1',
]

# CORS settings if you have a separate frontend
CORS_ALLOWED_ORIGINS = [
    "https://your-frontend-domain.com",  # Replace with your frontend domain
    "https://your-faceswap-app.fly.dev",
]

# Stripe settings
STRIPE_PUBLISHABLE_KEY = env("STRIPE_PUBLISHABLE_KEY")
STRIPE_SECRET_KEY = env("STRIPE_SECRET_KEY")
STRIPE_WEBHOOK_SECRET = env("STRIPE_WEBHOOK_SECRET")

# Logging for production
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'root': {
        'handlers': ['console'],
        'level': 'INFO',
    },
    'loggers': {
        'django': {
            'handlers': ['console'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}



# ==== django_project/settings/base.py ====

from environ import Env
from pathlib import Path
import stripe
import os

print("💥 settings.py loaded from latest build")
# Add this section to your settings.py after the imports but before the installed apps


# Cloudinary Configuration
import cloudinary
import cloudinary.uploader
import cloudinary.api

# Initialize environment variables
env = Env()
Env.read_env()

# Use CLOUDINARY_URL if available (Heroku style), otherwise use individual vars
cloudinary_url = env('CLOUDINARY_URL', default='')
if cloudinary_url:
    # Parse the cloudinary://api_key:api_secret@cloud_name format
    import re
    match = re.match(r'cloudinary://(\d+):([^@]+)@(.+)', cloudinary_url)
    if match:
        api_key, api_secret, cloud_name = match.groups()
        CLOUDINARY_STORAGE = {
            'CLOUD_NAME': cloud_name,
            'API_KEY': api_key,
            'API_SECRET': api_secret,
        }
        print(f"✅ Cloudinary configured from CLOUDINARY_URL for cloud: {cloud_name}")
    else:
        raise ValueError("Invalid CLOUDINARY_URL format")
else:
    # Fallback to individual environment variables
    CLOUDINARY_STORAGE = {
        'CLOUD_NAME': env('CLOUDINARY_CLOUD_NAME', default='dddye9wli'),
        'API_KEY': env('CLOUDINARY_API_KEY', default=''),
        'API_SECRET': env('CLOUDINARY_API_SECRET', default=''),
    }
    print("⚠️  Using individual Cloudinary env vars")

cloudinary.config(
    cloud_name=CLOUDINARY_STORAGE['CLOUD_NAME'],
    api_key=CLOUDINARY_STORAGE['API_KEY'],
    api_secret=CLOUDINARY_STORAGE['API_SECRET'],
    secure=True
)



# Stripe
STRIPE_PUBLISHABLE_KEY = env('STRIPE_PUBLISHABLE_KEY', default='pk_test_dummy')
STRIPE_SECRET_KEY = env('STRIPE_SECRET_KEY', default='sk_test_dummy')
STRIPE_WEBHOOK_SECRET = env('STRIPE_WEBHOOK_SECRET', default='whsec_dummy')
stripe.api_key = STRIPE_SECRET_KEY

OPENAI_API_KEY = env("OPENAI_API_KEY", default="")

# Base directory
BASE_DIR = Path(__file__).resolve().parent.parent

# Security
SECRET_KEY = env("DJANGO_SECRET_KEY", default="No Secret Key Found")
DEBUG = env.bool("DJANGO_DEBUG", default=False)
SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")

# Hosts
ALLOWED_HOSTS = env.list("DJANGO_ALLOWED_HOSTS", default=[
    "localhost", "127.0.0.1", "0.0.0.0", "web"
])

# Installed apps
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'cloudinary_storage',
    'cloudinary',

    # Custom apps
    'accounts.apps.AccountsConfig',
    'chat.apps.ChatConfig',
    'faceswap.apps.FaceswapConfig',  # Add this line

    # Third-party
    'django.contrib.sites',
    'allauth',
    'allauth.account',
    'allauth.socialaccount',
    'allauth.socialaccount.providers.google',

    'imagegen',


    'rest_framework',
    'rest_framework.authtoken', 


]

# Middleware
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'allauth.account.middleware.AccountMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'django_project.urls'

# Templates
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR.parent / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'django_project.wsgi.application'

# Database
DATABASES = {
    "default": env.db_url("DATABASE_URL")
}

# Auth
AUTH_USER_MODEL = 'accounts.CustomUser'
AUTHENTICATION_BACKENDS = [
    'django.contrib.auth.backends.ModelBackend',
    'allauth.account.auth_backends.AuthenticationBackend',
]

# Allauth
SITE_ID = env.int("DJANGO_SITE_ID", default=1)
ACCOUNT_AUTHENTICATION_METHOD = 'email'
ACCOUNT_USERNAME_REQUIRED = False
ACCOUNT_EMAIL_REQUIRED = True
ACCOUNT_USER_MODEL_USERNAME_FIELD = "email"
ACCOUNT_EMAIL_VERIFICATION = 'optional'
ACCOUNT_SIGNUP_REDIRECT_URL = '/dashboard/'
LOGIN_REDIRECT_URL = '/accounts/dashboard/'
LOGOUT_REDIRECT_URL = '/'

SOCIALACCOUNT_PROVIDERS = {
    'google': {
        'SCOPE': ['profile', 'email'],
        'AUTH_PARAMS': {'access_type': 'online'},
        'OAUTH_PKCE_ENABLED': True,
        'APP': {
            'client_id': env('GOOGLE_CLIENT_ID', default='test-client-id'),
            'secret': env('GOOGLE_CLIENT_SECRET', default='test-secret'),
            'key': ''
        }
    }
}

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},
    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},
    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},
    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},
]

# Localization
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_TZ = True

# Static
STATIC_URL = "/static/"
STATICFILES_DIRS = [BASE_DIR.parent / "static"]
STATIC_ROOT = BASE_DIR.parent / "staticfiles"
STATICFILES_STORAGE = "whitenoise.storage.CompressedManifestStaticFilesStorage"

# Media
DEFAULT_FILE_STORAGE = 'cloudinary_storage.storage.MediaCloudinaryStorage'

# Staticfiles finders
STATICFILES_FINDERS = [
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
]

# Email
EMAIL_BACKEND = env("EMAIL_BACKEND", default="django.core.mail.backends.locmem.EmailBackend")
EMAIL_HOST = env("EMAIL_HOST", default="smtp.test.com")
EMAIL_PORT = env.int("EMAIL_PORT", default=587)
EMAIL_USE_TLS = env.bool("EMAIL_USE_TLS", default=True)
EMAIL_HOST_USER = env("EMAIL_HOST_USER", default="test@test.com")
EMAIL_HOST_PASSWORD = env("EMAIL_HOST_PASSWORD", default="testpassword")
DEFAULT_FROM_EMAIL = env("DEFAULT_FROM_EMAIL", default="noreply@test.com")

# Security
if not DEBUG:
    SECURE_SSL_REDIRECT = env.bool("DJANGO_SECURE_SSL_REDIRECT", default=True)
    SECURE_HSTS_SECONDS = env.int("DJANGO_SECURE_HSTS_SECONDS", default=2592000)
    SECURE_HSTS_INCLUDE_SUBDOMAINS = env.bool("DJANGO_SECURE_HSTS_INCLUDE_SUBDOMAINS", default=True)
    SECURE_HSTS_PRELOAD = env.bool("DJANGO_SECURE_HSTS_PRELOAD", default=True)
    SESSION_COOKIE_SECURE = env.bool("DJANGO_SESSION_COOKIE_SECURE", default=True)
    CSRF_COOKIE_SECURE = env.bool("DJANGO_CSRF_COOKIE_SECURE", default=True)
else:
    SECURE_SSL_REDIRECT = False
    SECURE_HSTS_SECONDS = 0
    SECURE_HSTS_INCLUDE_SUBDOMAINS = False
    SECURE_HSTS_PRELOAD = False
    SESSION_COOKIE_SECURE = False
    CSRF_COOKIE_SECURE = False

# Other
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.TokenAuthentication',
        'rest_framework.authentication.SessionAuthentication',
    ]
}
HUGGINGFACE_FACESWAP_URL = env('HUGGINGFACE_FACESWAP_URL', 
    default='https://mnraynor90-facefusionfastapi.hf.space')



# ==== scripts/export_code_snapshot.py ====

import os

# Directories to include
INCLUDE_DIRS = [
    "accounts", "chat", "imagegen", "django_project", "scripts"
]

# File extensions to include
INCLUDE_EXTENSIONS = [".py", ".json", ".html", ".js", ".ts", ".css"]

# Directories to exclude
EXCLUDE_DIRS = {"__pycache__", "migrations", "venv", "env", "node_modules", "media", "static", ".git"}

# Output file
OUTPUT_PATH = os.path.join("scripts", "code_snapshot.txt")

def should_include(file_path):
    return any(file_path.endswith(ext) for ext in INCLUDE_EXTENSIONS)

def walk_and_collect():
    collected = []

    for base_dir in INCLUDE_DIRS:
        for root, dirs, files in os.walk(base_dir):
            dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS]
            for file in files:
                full_path = os.path.join(root, file)
                rel_path = os.path.relpath(full_path)
                if should_include(full_path):
                    with open(full_path, "r", encoding="utf-8", errors="ignore") as f:
                        content = f.read()
                    collected.append((rel_path, content))

    return collected

def write_snapshot(files):
    with open(OUTPUT_PATH, "w", encoding="utf-8") as out:
        for path, code in files:
            out.write(f"\n\n# ==== {path} ====\n\n")
            out.write(code)
            out.write("\n\n")

if __name__ == "__main__":
    collected_files = walk_and_collect()
    write_snapshot(collected_files)
    print(f"✅ Snapshot created: {OUTPUT_PATH} ({len(collected_files)} files)")




# ==== scripts/embed_cloudinary_faces.py ====

import face_recognition
import os
import json
import requests
import tempfile
from pathlib import Path

# Django setup
import sys
import django
sys.path.append(str(Path(__file__).resolve().parent.parent))
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django_project.settings.dev')
django.setup()

BASE_DIR = Path(__file__).resolve().parent.parent
output_file = BASE_DIR / "face_data" / "embeddings.json"

# Your Cloudinary URLs mapped to clean names
HISTORICAL_FIGURES = {
    "Princess Diana": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921365/princess_diana_ueb9ha.png",
    "Marilyn Monroe": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921365/marilyn_monroe_geys6v.png",
    "Pocahontas": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921365/Pocahontas_kp0obo.png",
    "Napoleon": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921365/napolean_ukozvo.png",
    "Marie Antoinette": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921363/Marie_Antoinette_fvjtgy.png",
    "Keith Haring": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921362/keith_k7b5xw.png",
    "Malcolm X": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921362/malcolm_x_a8sluo.png",
    "Jimi Hendrix": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921362/jimi_hendrix_u07bvu.png",
    "Joan of Arc": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921362/Joan_of_Arc_vvi28l.png",
    "Leonardo da Vinci": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921362/leonardo_davinci_lv7gy8.png",
    "Cleopatra": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921359/cleopatra_zcslcx.png",
    "Frida Kahlo": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921358/frida_khalo_wq6qyl.png",
    "JFK": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921358/jfk_rznzq0.png",
    "James Dean": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921358/james_dean_wvmc5c.png",
    "Coco Chanel": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921358/Coco_Chanel_mnx6s9.png",
    "Elvis Presley": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921841/elvis_heazqa.png",
    "Che Guevara": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921355/Che_Guevara_n8nmln.png",
    "Alexander the Great": "https://res.cloudinary.com/dddye9wli/image/upload/v1749921354/alexander_the_great_mcdwpy.png",
}

def download_and_encode_face(name, url):
    """Download image from URL and extract face encoding"""
    try:
        print(f"📥 Processing {name}...")
        
        # Download image to temporary file
        response = requests.get(url, timeout=30)
        response.raise_for_status()
        
        # Save to temporary file
        with tempfile.NamedTemporaryFile(delete=False, suffix='.jpg') as tmp_file:
            tmp_file.write(response.content)
            tmp_path = tmp_file.name
        
        try:
            # Load and process with face_recognition
            image = face_recognition.load_image_file(tmp_path)
            face_locations = face_recognition.face_locations(image)
            
            if not face_locations:
                print(f"❌ No face found in {name}, skipping.")
                return None
            
            if len(face_locations) > 1:
                print(f"⚠️  Multiple faces found in {name}, using the first one.")
            
            # Get face encoding
            encoding = face_recognition.face_encodings(image, known_face_locations=face_locations)[0]
            
            print(f"✅ Successfully encoded {name}")
            return {
                "name": name,
                "embedding": encoding.tolist(),
                "url": url
            }
            
        finally:
            # Clean up temporary file
            try:
                os.unlink(tmp_path)
            except:
                pass
                
    except Exception as e:
        print(f"❌ Error processing {name}: {str(e)}")
        return None

def main():
    print("🚀 Starting face embedding generation from Cloudinary...")
    print(f"📁 Output file: {output_file}")
    
    # Ensure output directory exists
    output_file.parent.mkdir(parents=True, exist_ok=True)
    
    embeddings = []
    
    for name, url in HISTORICAL_FIGURES.items():
        result = download_and_encode_face(name, url)
        if result:
            embeddings.append(result)
        print()  # Add blank line for readability
    
    # Save to JSON
    try:
        with open(output_file, "w") as f:
            json.dump(embeddings, f, indent=2)
        
        print(f"🎉 SUCCESS! Saved {len(embeddings)} embeddings to {output_file}")
        print(f"📊 Successfully processed: {len(embeddings)}/{len(HISTORICAL_FIGURES)} figures")
        
        # Print summary
        print("\n📋 Generated embeddings for:")
        for embedding in embeddings:
            print(f"  • {embedding['name']}")
            
    except Exception as e:
        print(f"❌ Error saving embeddings: {str(e)}")

if __name__ == "__main__":
    main()

